<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Celestial • Simulonic × Infosophic Lab • Intent Sextant (Hardened)</title>
<style>
  :root{--bg:#0f1115;--panel:#161a22;--card:#1c2230;--text:#e8eef7;--muted:#9bb0c8;--accent:#61dafb;--good:#6ee7a6;--warn:#fbbf24;--grid:#2a3242;--hl:#9f7aea;--bad:#f87171}
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#0c0f14,#0f1115);color:var(--text);font:14px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif}
  header{position:sticky;top:0;z-index:10;display:flex;align-items:center;justify-content:space-between;padding:12px 16px;border-bottom:1px solid #202636;background:rgba(22,26,34,.85);backdrop-filter:blur(6px)}
  .brand{display:flex;gap:10px;align-items:center}
  .logo{width:36px;height:36px;border-radius:10px;background:radial-gradient(circle at 30% 30%,#7cfcff,#4c50ff 45%,#1f1340 70%);box-shadow:0 0 24px rgba(97,218,251,.35),inset 0 0 18px rgba(255,255,255,.12)}
  .title{font-weight:700}.sub{font-size:12px;color:var(--muted)}
  #stageWrap{position:relative;width:100%;height:calc(100vh - 64px)}
  canvas{display:block;width:100%;height:100%;background:linear-gradient(180deg,#0b0e17,#0a0d14)}
  .panel{position:absolute;top:12px;left:12px;width:520px;max-width:calc(100% - 24px);border:1px solid #232a3a;background:rgba(22,26,34,.9);border-radius:14px;padding:12px;box-shadow:0 10px 30px rgba(0,0,0,.25),inset 0 0 0 1px rgba(255,255,255,.02)}
  .panel .h{font-size:12px;text-transform:uppercase;letter-spacing:.12em;color:var(--muted);margin:2px 0 8px}
  .row{display:flex;gap:10px;align-items:center;margin:8px 0}
  .row input[type="range"]{flex:1}
  .btn{padding:7px 10px;background:var(--card);border:1px solid #2a3147;color:var(--text);border-radius:10px;cursor:pointer;font-size:13px}
  .btn:hover{border-color:#3a425e}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;font-size:12px}
  textarea.code{width:100%;min-height:150px;resize:vertical;border:1px solid #283048;border-radius:12px;background:#151a26;color:#e8eef7;padding:10px;outline:none}
  .legend{position:absolute;right:12px;top:12px;background:rgba(16,20,30,.78);padding:8px 10px;border:1px solid #27304a;border-radius:10px;font-size:12px}
  .pill{display:inline-block;padding:2px 8px;border-radius:999px;margin:2px 2px;border:1px solid #2a3250}
  .pill.blue{background:rgba(97,218,251,.12);color:#bdefff}
  .pill.green{background:rgba(110,231,166,.12);color:#c7f8de}
  .pill.purple{background:rgba(159,122,234,.12);color:#e1d1ff}
  .pill.gold{background:rgba(251,191,36,.12);color:#ffe3a3}
  .pill.pos{background:rgba(110,231,166,.12);color:#bdf8dc;border-color:#245c41}
  .pill.neg{background:rgba(248,113,113,.12);color:#ffd1d1;border-color:#5c2424}
  .stats{position:absolute;right:12px;bottom:12px;background:rgba(16,20,30,.78);padding:10px;border:1px solid #27304a;border-radius:10px;font-size:12px}
  .statLine{display:flex;justify-content:space-between;gap:12px;margin:4px 0}
  .muted{color:var(--muted)}
  .outlookGrid{display:grid;grid-template-columns:1fr auto;gap:6px;background:rgba(21,26,38,.7);border:1px solid #27304a;border-radius:10px;padding:8px;margin:8px 0}
  .toggle{padding:4px 8px;border-radius:999px;border:1px solid #2a3147;cursor:pointer;font-size:12px;background:linear-gradient(180deg,#1f2a44,#1a2440)}
  .toggle.pos{border-color:#2b6b54}.toggle.neg{border-color:#6b2b2b}
  .swatch{display:inline-block;width:10px;height:10px;border-radius:50%;margin-right:6px;vertical-align:middle}
  .note{font-size:11px;color:var(--muted);margin-top:6px;line-height:1.35}
  .lensHUD{position:absolute;left:50%;transform:translateX(-50%);bottom:12px;background:rgba(16,20,30,.78);padding:8px 10px;border:1px solid #27304a;border-radius:10px;font-size:12px;display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .chk{display:flex;align-items:center;gap:8px;font-size:12px}
  .log{margin-top:8px;border:1px solid #283048;border-radius:12px;background:#0f1524;max-height:180px;overflow:auto;padding:8px;font:12px/1.5 ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;color:#cfe8ff}
  .log .line{border-bottom:1px dashed rgba(255,255,255,.06);padding:6px 0}
  .log .tag{display:inline-block;padding:2px 6px;border-radius:999px;border:1px solid #2a3250;margin-right:6px}
  .tag.exec{background:rgba(159,122,234,.15);color:#e1d1ff}.tag.ctx{background:rgba(97,218,251,.12);color:#bdefff}
</style>
</head>
<body>
<header>
  <div class="brand">
    <div class="logo"></div>
    <div>
      <div class="title">Celestial • Simulonic × Infosophic Lab</div>
      <div class="sub">Sky dome • Lens • Dynamic Pareto • SimuLang • Auto Sextant • CII Intent Vector</div>
    </div>
  </div>
  <div class="sub">Infosophic: Gösta Greimel • Simulonic: Hrishi Mukherjee • Integration: Greimel & Mukherjee • OBT: Oliver Boeschenstein</div>
</header>

<div id="stageWrap">
  <canvas id="stage"></canvas>

  <div class="panel" id="ctrlPanel">
    <div class="h">Observer & Sextant</div>
    <div class="row">
      <span class="muted">Observer Lon</span><input id="rngObsLon" type="range" min="-180" max="180" step="1"><span class="mono" id="labObsLon"></span>
    </div>
    <div class="row">
      <span class="muted">Observer Lat</span><input id="rngObsLat" type="range" min="-80" max="80" step="1"><span class="mono" id="labObsLat"></span>
    </div>
    <div class="row">
      <div class="chk"><input id="chkAutoSextant" type="checkbox"><label for="chkAutoSextant">Auto Sextant Lock</label></div>
      <span class="muted">Lock speed</span>
      <input id="rngAutoSpeed" type="range" min="0.02" max="0.5" step="0.01" value="0.15" style="flex:1">
      <span class="mono" id="labAutoSpeed">0.15</span>
    </div>

    <div class="h">CII Intent Vector (sky)</div>
    <div class="row"><span class="muted">Bearing (az°)</span><input id="rngBearing" type="range" min="0" max="360" step="1"><span class="mono" id="labBearing"></span></div>
    <div class="row"><span class="muted">Elevation (alt°)</span><input id="rngAlt" type="range" min="0" max="90" step="1"><span class="mono" id="labAlt"></span></div>
    <div class="row"><span class="muted">Magnitude</span><input id="rngMag" type="range" min="0" max="1" step="0.01" value="0.7"><span class="mono" id="labMag">0.70</span></div>
    <div class="row"><span class="muted">Gain</span><input id="rngGain" type="range" min="0" max="2" step="0.01" value="0.6"><span class="mono" id="labGain">0.60</span></div>

    <div class="h">Dynamic Pareto & ART</div>
    <div class="row"><span class="muted">τ (manual)</span><input id="rngTau" type="range" min="0.05" max="1.5" step="0.01"><span class="mono" id="labTau"></span></div>
    <div class="row chk"><input id="chkAutoPareto" type="checkbox" /><label for="chkAutoPareto">Auto Pareto (keep ~20% head for target mass)</label></div>
    <div class="row"><span class="muted">Target head mass</span><input id="rngTargetMass" type="range" min="0.50" max="0.95" step="0.01" style="flex:1"><span class="mono" id="labTargetMass"></span></div>

    <div class="row"><span class="muted">ν (DOF)</span><input id="rngNu" type="range" min="1" max="12" step="1"><span class="mono" id="labNu"></span></div>
    <div class="row"><span class="muted">Points</span><input id="rngPts" type="range" min="60" max="3000" step="20"><span class="mono" id="labPts"></span></div>
    <div class="row"><span class="muted">Mood Strength</span><input id="rngMood" type="range" min="0" max="2" step="0.05" style="flex:1"><span class="mono" id="labMood"></span></div>
    <div class="row"><button class="btn" id="btnShuffle">Shuffle Seed</button><button class="btn" id="btnClear">Clear Lock-ons</button></div>

    <div class="h">Outlooks (per dimension)</div>
    <div id="outlookGrid" class="outlookGrid"></div>
    <div class="note">Simulation labels only—abstract categories to test geometry. No real-world judgments are implied.</div>

    <div class="h">SimuLang Hook (mini) + Runtime</div>
    <textarea id="simTxt" class="code mono" spellcheck="false"></textarea>
    <div class="row">
      <div class="chk"><input id="chkAutoExec" type="checkbox"><label for="chkAutoExec">Auto-exec on lock & lens</label></div>
      <button class="btn" id="btnRun">Run Now</button>
      <button class="btn" id="btnReset">Reset</button>
    </div>
    <div id="runtimeLog" class="log"></div>
    <div class="row"><button class="btn" id="btnApply">Apply SimuLang</button></div>
  </div>

  <div class="legend">
    <span class="pill blue">ART t-field</span>
    <span class="pill green">Lock-on</span>
    <span class="pill purple">Infosophic ⇄ Simulonic</span>
    <span class="pill gold">ds² gauges</span>
    <span class="pill pos">Optimistic</span>
    <span class="pill neg">Pessimistic</span>
  </div>

  <div class="stats" id="statsBox">
    <div class="statLine"><span class="muted">ds² (Green)</span><span class="mono" id="statG">0.000</span></div>
    <div class="statLine"><span class="muted">ds² (Vacuum)</span><span class="mono" id="statV">0.000</span></div>
    <div class="statLine"><span class="muted">Locked</span><span class="mono" id="statL">0</span></div>
    <div class="statLine"><span class="muted">τ</span><span class="mono" id="statT">0.00</span></div>
    <div class="statLine"><span class="muted">Head k/N</span><span class="mono" id="statK">0/0</span></div>
    <div class="statLine"><span class="muted">Head mass</span><span class="mono" id="statMass">0.00</span></div>
    <div class="statLine"><span class="muted">Optimistic</span><span class="mono" id="statPos">0</span></div>
    <div class="statLine"><span class="muted">Pessimistic</span><span class="mono" id="statNeg">0</span></div>
  </div>

  <div class="lensHUD">
    <button class="btn" id="btnLensMode">Lens: Infosophic (I)</button>
    <span class="muted">Angular radius</span>
    <input id="rngLensR" type="range" min="5" max="60" step="1" style="width:200px">
    <span class="mono" id="labLensR">20°</span>
    <span class="muted">Drag the circle • Press S to switch to Simulonic</span>
  </div>
</div>

<script>
// --- roundRect polyfill for older canvases ---
if (!CanvasRenderingContext2D.prototype.roundRect) {
  CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
    const rr = Array.isArray(r) ? r : [r, r, r, r].map(v => Math.max(0, v || 0));
    const [r1, r2, r3, r4] = rr;
    this.beginPath();
    this.moveTo(x + r1, y);
    this.lineTo(x + w - r2, y);
    this.quadraticCurveTo(x + w, y, x + w, y + r2);
    this.lineTo(x + w, y + h - r3);
    this.quadraticCurveTo(x + w, y + h, x + w - r3, y + h);
    this.lineTo(x + r4, y + h);
    this.quadraticCurveTo(x, y + h, x, y + h - r4);
    this.lineTo(x, y + r1);
    this.quadraticCurveTo(x, y, x + r1, y);
  };
}

/* ===== DOM safe getters ===== */
const $ = id => { const el = document.getElementById(id); if(!el) throw new Error('Missing element '+id); return el; };
const stage=$('stage'), ctx=stage.getContext('2d');
const E={
  rngObsLon:$('rngObsLon'), labObsLon:$('labObsLon'),
  rngObsLat:$('rngObsLat'), labObsLat:$('labObsLat'),
  chkAutoSextant:$('chkAutoSextant'), rngAutoSpeed:$('rngAutoSpeed'), labAutoSpeed:$('labAutoSpeed'),
  rngBearing:$('rngBearing'), labBearing:$('labBearing'),
  rngAlt:$('rngAlt'), labAlt:$('labAlt'),
  rngMag:$('rngMag'), labMag:$('labMag'),
  rngGain:$('rngGain'), labGain:$('labGain'),
  rngTau:$('rngTau'), labTau:$('labTau'), chkAutoPareto:$('chkAutoPareto'), rngTargetMass:$('rngTargetMass'), labTargetMass:$('labTargetMass'),
  rngNu:$('rngNu'), labNu:$('labNu'), rngPts:$('rngPts'), labPts:$('labPts'), rngMood:$('rngMood'), labMood:$('labMood'),
  btnShuffle:$('btnShuffle'), btnClear:$('btnClear'), outlookGrid:$('outlookGrid'),
  simTxt:$('simTxt'), btnApply:$('btnApply'), btnReset:$('btnReset'), chkAutoExec:$('chkAutoExec'), btnRun:$('btnRun'), runtimeLog:$('runtimeLog'),
  btnLensMode:$('btnLensMode'), rngLensR:$('rngLensR'), labLensR:$('labLensR'),
  statG:$('statG'), statV:$('statV'), statL:$('statL'), statT:$('statT'), statK:$('statK'), statMass:$('statMass'), statPos:$('statPos'), statNeg:$('statNeg')
};

/* ===== Canvas fit ===== */
function fitCanvas(){const h=document.querySelector('header').offsetHeight||64; $('stageWrap').style.height=`calc(100vh - ${h}px)`;
  const dpr=Math.max(1,devicePixelRatio||1); stage.width=Math.floor(stage.clientWidth*dpr); stage.height=Math.floor(stage.clientHeight*dpr); ctx.setTransform(dpr,0,0,dpr,0,0);} 
addEventListener('resize',fitCanvas,{passive:true}); fitCanvas();

/* ===== Math utils ===== */
const toRad=d=>d*Math.PI/180, toDeg=r=>r*180/Math.PI;
function rng(seed){let t=seed>>>0; return ()=>{t+=0x6D2B79F5; let r=Math.imul(t^(t>>>15),1|t); r^=r+Math.imul(r^(r>>>7),61|r); return ((r^(r>>>14))>>>0)/4294967296;};}
function randn(r){let u=1-r(),v=1-r(); return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);} 
function chiSquare(df,r){let s=0;for(let i=0;i<df;i++){const z=randn(r); s+=z*z;} return s;}
function studentT(df,r){const z=randn(r); return z/Math.sqrt(chiSquare(df,r)/df);} 
function softmax(a,t=1){const m=Math.max(...a); const ex=a.map(v=>Math.exp((v-m)/Math.max(1e-6,t))); const s=ex.reduce((x,y)=>x+y,0); return ex.map(e=>e/s);} 

/* ===== Projections (sky only) ===== */
function projBase(){const R=Math.min(stage.clientWidth,stage.clientHeight)*0.42;const cx=stage.clientWidth/2,cy=stage.clientHeight/2;return {R,cx,cy};}
function sphToAltAz(lon,lat,obsLon,obsLat){const lam=toRad(lon),phi=toRad(lat),lam0=toRad(obsLon),phi0=toRad(obsLat);
  const sinEl=Math.sin(phi0)*Math.sin(phi)+Math.cos(phi0)*Math.cos(phi)*Math.cos(lam-lam0);
  const Az=Math.atan2(Math.sin(lam-lam0)*Math.cos(phi), Math.cos(phi0)*Math.sin(phi)-Math.sin(phi0)*Math.cos(phi)*Math.cos(lam-lam0));
  const alt=Math.asin(Math.max(-1,Math.min(1,sinEl))); const c=Math.acos(Math.max(-1,Math.min(1,sinEl)));
  return {alt:toDeg(alt), az:(toDeg(Az)+360)%360, c:toDeg(c)};}
function projSky(az,alt){const {R,cx,cy}=projBase();const k=R*0.9/90;const r=(90-alt)*k;const th=toRad(az);const x=cx+r*Math.sin(th),y=cy-r*Math.cos(th);return {x,y,visible:alt>=0,rho:r,cx,cy,R:R*0.9};}
function invSky(x,y){const {R,cx,cy}=projBase();const k=R*0.9/90;const dx=x-cx,dy=y-cy;const r=Math.hypot(dx,dy);if(r>R*0.9+2) return null;const az=((toDeg(Math.atan2(dx,-dy))+360)%360);const alt=90-r/k;return {az,alt};}

/* ===== State ===== */
const DIMENSIONS=['Dynasty','Empire','Family', 'Field'];
let outlook=Object.fromEntries(DIMENSIONS.map(d=>[d,+1]));
let seed=42, points=[], weights=[], lockSet=new Set();
const globe={lon0:0,lat0:15,dragging:false,lastX:0,lastY:0};
const lens={az:0,alt:60, ang:20, mode:'infosophic', dragging:false};
const auto={enabled:false, speed:0.15, targetAz:null, targetAlt:null, cooldown:0};
const intent={bearing:0, alt:45, mag:0.7, gain:0.6};
let cfg;

E.labAutoSpeed.textContent=auto.speed.toFixed(2);

/* ===== SimuLang ===== */
function defaultSimuLang(){return `# SimuLang (runtime)\npareto.tau = 0.55\nquality.q = 1.00\nart.nu = 3\nart.points = 900\nlockon.k = 8\nmood.strength = 1.0\nauto.pareto = true\ntarget.mass = 0.80\n# Intent Vector (sky)\nintent.bearing = 0\nintent.alt = 45\nintent.magnitude = 0.70\nintent.gain = 0.60\n# observer\nobserver.lon = 0\nobserver.lat = 15\n# runtime:\nexecute.mode = auto\nexecute.metric = lens_intensity\n`; }
function parseSimuLang(src){
  const c={paretoTau:0.55,qualityQ:1.0,artNu:3,artPoints:900,lockTopK:8,moodStrength:1.0,autoPareto:true,targetMass:0.80,obsLon:0,obsLat:15,intBearing:0,intAlt:45,intMag:0.7,intGain:0.6,execMode:'auto',execMetric:'lens_intensity'};
  for(const raw of src.split('\n')){const l=raw.trim(); if(!l||l.startsWith('#')) continue; const m=l.match(/^([a-z._]+)\s*=\s*(.+)$/i); if(!m) continue; const k=m[1].toLowerCase(), v=m[2].trim();
    if(k==='pareto.tau') c.paretoTau=parseFloat(v);
    else if(k==='quality.q') c.qualityQ=parseFloat(v);
    else if(k==='art.nu') c.artNu=Math.max(1,parseInt(v));
    else if(k==='art.points') c.artPoints=Math.max(10,Math.min(5000,parseInt(v)));
    else if(k==='lockon.k') c.lockTopK=Math.max(0,parseInt(v));
    else if(k==='mood.strength') c.moodStrength=Math.max(0,parseFloat(v));
    else if(k==='auto.pareto') c.autoPareto=(v.toLowerCase()==='true');
    else if(k==='target.mass') c.targetMass=Math.min(0.95,Math.max(0.5,parseFloat(v)));
    else if(k==='intent.bearing') c.intBearing=parseFloat(v);
    else if(k==='intent.alt') c.intAlt=parseFloat(v);
    else if(k==='intent.magnitude') c.intMag=parseFloat(v);
    else if(k==='intent.gain') c.intGain=parseFloat(v);
    else if(k==='observer.lon') c.obsLon=parseFloat(v);
    else if(k==='observer.lat') c.obsLat=parseFloat(v);
    else if(k==='execute.mode') c.execMode=v.toLowerCase();
    else if(k==='execute.metric') c.execMetric=v.toLowerCase();
  }
  // harden
  if(!Number.isFinite(c.artPoints)||c.artPoints<10) c.artPoints=900;
  if(!Number.isFinite(c.artNu)||c.artNu<1) c.artNu=3;
  if(!Number.isFinite(c.paretoTau)||c.paretoTau<=0) c.paretoTau=0.55;
  if(!Number.isFinite(c.qualityQ)||c.qualityQ<=0) c.qualityQ=1.0;
  if(!Number.isFinite(c.intMag)) c.intMag=0.7;
  if(!Number.isFinite(c.intGain)) c.intGain=0.6;
  if(!Number.isFinite(c.intBearing)) c.intBearing=0;
  if(!Number.isFinite(c.intAlt)) c.intAlt=45;
  if(!Number.isFinite(c.obsLon)) c.obsLon=0;
  if(!Number.isFinite(c.obsLat)) c.obsLat=15;
  return c;
}

/* ===== UI sync ===== */
function hueForDim(i){return (i*37)%360;}
function buildOutlookGrid(){
  E.outlookGrid.innerHTML='';
  DIMENSIONS.forEach((d,i)=>{
    const label=document.createElement('div'); const sw=document.createElement('span'); sw.className='swatch'; sw.style.background=`hsl(${hueForDim(i)} 80% 60%)`;
    label.appendChild(sw); label.appendChild(document.createTextNode(d));
    const btn=document.createElement('button'); const isPos=outlook[d]>=0;
    btn.className='toggle '+(isPos?'pos':'neg'); btn.textContent=isPos?'Optimistic':'Pessimistic';
    btn.addEventListener('click',()=>{outlook[d]=(outlook[d]>=0)?-1:+1; buildART(); ensurePoints(); computeSkyAutoTarget();});
    E.outlookGrid.appendChild(label); E.outlookGrid.appendChild(btn);
  });
}
function syncControls(){
  E.rngTau.value=cfg.paretoTau; E.labTau.textContent=cfg.paretoTau.toFixed(2); E.statT.textContent=cfg.paretoTau.toFixed(2);
  E.chkAutoPareto.checked=cfg.autoPareto; E.rngTargetMass.value=cfg.targetMass; E.labTargetMass.textContent=cfg.targetMass.toFixed(2);
  E.rngNu.value=cfg.artNu; E.labNu.textContent=cfg.artNu;
  E.rngPts.value=cfg.artPoints; E.labPts.textContent=cfg.artPoints;
  E.rngMood.value=cfg.moodStrength; E.labMood.textContent=cfg.moodStrength.toFixed(2);
  E.rngLensR.value=lens.ang; E.labLensR.textContent=`${lens.ang}°`;
  E.rngBearing.value=intent.bearing=cfg.intBearing; E.labBearing.textContent=`${Math.round(intent.bearing)}°`;
  E.rngAlt.value=intent.alt=cfg.intAlt; E.labAlt.textContent=`${Math.round(intent.alt)}°`;
  E.rngMag.value=intent.mag=cfg.intMag; E.labMag.textContent=intent.mag.toFixed(2);
  E.rngGain.value=intent.gain=cfg.intGain; E.labGain.textContent=intent.gain.toFixed(2);
  globe.lon0=cfg.obsLon; globe.lat0=cfg.obsLat; E.rngObsLon.value=globe.lon0; E.labObsLon.textContent=`${Math.round(globe.lon0)}°`; E.rngObsLat.value=globe.lat0; E.labObsLat.textContent=`${Math.round(globe.lat0)}°`;
  E.chkAutoExec.checked=(cfg.execMode==='auto');
  E.rngAutoSpeed.value=auto.speed; E.labAutoSpeed.textContent=auto.speed.toFixed(2);
}

/* ===== Field generation & weights (sky only, with Intent Vector) ===== */
function skyVec(azDeg,altDeg){ const az=toRad(azDeg), alt=toRad(altDeg); const c=Math.cos(alt); return {x:c*Math.sin(az), y:c*Math.cos(az), z:Math.sin(alt)}; }
function dot(a,b){return a.x*b.x+a.y*b.y+a.z*b.z;}
function recomputeWeights(){weights=softmax(points.map(p=>p.sal),Math.max(0.05,cfg.paretoTau));}
function buildART(){
  const r=rng(seed); points=[]; let pos=0,neg=0;
  const centerAz=lens.az, centerAlt=lens.alt; // lens-centered sampling notion
  const scaleAz=40, scaleAlt=25;
  const V=skyVec(intent.bearing, intent.alt);
  for(let i=0;i<cfg.artPoints;i++){
    const dim=DIMENSIONS[i%DIMENSIONS.length];
    const daz=studentT(cfg.artNu,r)*scaleAz, dalt=studentT(cfg.artNu,r)*scaleAlt;
    let az=(centerAz+daz+360)%360, alt=Math.max(0,Math.min(90,centerAlt+dalt));
    const P=skyVec(az,alt);
    const align = Math.max(0, dot(V,P)); // [0,1]
    const angDist = Math.acos(Math.max(-1, Math.min(1, dot(skyVec(centerAz,centerAlt), P) )));
    const base=1/(1+(angDist/(Math.PI/4))**2);
    const mood=outlook[dim]||+1;
    const moodGain=1+cfg.moodStrength*(mood*0.25);
    const sal=base * (1 + intent.mag * intent.gain * align) * moodGain;
    // map back to pseudo lon/lat for reuse of projection API (treat az as lon, 90-colat as lat)
    const lon=az; const lat=alt; 
    points.push({lon,lat,sal,dim,mood});
    if(mood>=0) pos++; else neg++;
  }
  const maxS=points.reduce((m,p)=>Math.max(m,p.sal),1e-6); for(const p of points){p.sal/=maxS;}
  recomputeWeights();
  lockSet.clear();
  if(cfg.lockTopK>0){ const top=[...points.map((p,i)=>[p.sal,i])].sort((a,b)=>b[0]-a[0]).slice(0,cfg.lockTopK).map(x=>x[1]); for(const i of top) lockSet.add(i); }
  E.statPos.textContent=pos; E.statNeg.textContent=neg;
}
function ensurePoints(){ if(!points || !Array.isArray(points) || points.length===0){ buildART(); } }

/* ===== Gauges & lens scoring ===== */
function computeDS2Dual(activeIdx){
  if(points.length===0) return {g:0,v:0};
  function posOf(p){ const P=projSky(p.lon, p.lat); return {x:P.x,y:P.y,vis:P.visible}; }
  let idx=activeIdx.length?activeIdx:[...points.map((p,i)=>[p.sal,i])].sort((a,b)=>b[0]-a[0]).slice(0,Math.max(3,Math.floor(points.length*0.05))).map(x=>x[1]);
  const Q=cfg.qualityQ||1, K=(a,b)=>{const dx=a.x-b.x,dy=a.y-b.y,d2=dx*dx+dy*dy;return Math.exp(-d2/3000);}, G=(a,b)=>1/(Math.hypot(a.x-b.x,a.y-b.y)+1e-3);
  let dsg=0,dsv=0; for(const i of idx){const pi=posOf(points[i]); if(!pi.vis) continue; for(let j=0;j<points.length;j++){const pj=posOf(points[j]); if(!pj.vis) continue; const wi=weights[i]/Q, wj=weights[j]/Q; dsg+=wi*wj*K(pi,pj); dsv+=wi*wj*G(pi,pj);} }
  const squash=v=>1-Math.exp(-v/50); return {g:squash(dsg), v:squash(dsv)};
}
function lensScores(){
  const kernel=(lens.mode==='infosophic')?(a)=>Math.exp(-(a*a)/25):(a)=>1/(a+1e-2);
  let scores=new Float32Array(points.length), sum=0;
  for(let i=0;i<points.length;i++){
    const P=projSky(points[i].lon,points[i].lat); if(P.visible===false){scores[i]=0; continue;}
    // angular distance in sky between lens center and point
    const ang= Math.acos( Math.max(-1, Math.min(1, dot(skyVec(lens.az,lens.alt), skyVec(points[i].lon, points[i].lat)) )) );
    const angDeg = toDeg(ang);
    if(angDeg>lens.ang){scores[i]=0;continue;}
    const s=(weights[i]/Math.max(0.5,cfg.qualityQ))*kernel(angDeg);
    scores[i]=s; sum+=s;
  }
  const m=Math.max(1e-6,...scores); for(let i=0;i<scores.length;i++) scores[i]/=m; const dsLocal=1-Math.exp(-sum/20); return {scores, dsLocal};
}

/* ===== Dynamic Pareto ===== */
function headStatsForTarget(target){const arr=weights.slice().sort((a,b)=>b-a); let cum=0,k=0; for(k=0;k<arr.length;k++){cum+=arr[k]; if(cum>=target) break;} return {k:k+1,headFrac:(k+1)/arr.length,mass:Math.min(1,cum)};}
function autoAdjustTau(dt){const {headFrac}=headStatsForTarget(cfg.targetMass); const err=headFrac-0.20; const step=-1.0*err*dt; cfg.paretoTau=Math.min(1.5,Math.max(0.05,cfg.paretoTau+step)); E.rngTau.value=cfg.paretoTau; E.labTau.textContent=cfg.paretoTau.toFixed(2); E.statT.textContent=cfg.paretoTau.toFixed(2); recomputeWeights();}

/* ===== Drawing (sky only) ===== */
function drawParetoBar(){ if(weights.length===0) return; const x=12,y=12,W=320,H=50; ctx.save(); ctx.fillStyle='rgba(16,20,30,.78)'; ctx.strokeStyle='#27304a'; ctx.lineWidth=1; ctx.beginPath(); ctx.roundRect(x,y,W,H,10); ctx.fill(); ctx.stroke();
  const arr=weights.slice().sort((a,b)=>b-a); let cum=0,kStar=arr.length; for(let i=0;i<arr.length;i++){cum+=arr[i]; if(cum>=cfg.targetMass){kStar=i+1; break;}} const headFrac=kStar/arr.length, headW=Math.floor(W*headFrac);
  ctx.fillStyle='rgba(110,231,166,.35)'; ctx.fillRect(x+1,y+H-16,headW-2,10); ctx.fillStyle='rgba(97,218,251,.25)'; ctx.fillRect(x+headW,y+H-16,W-headW-1,10);
  ctx.fillStyle='#cfe8ff'; ctx.font='12px ui-monospace'; ctx.fillText(`Pareto (runtime) — τ=${cfg.paretoTau.toFixed(2)} • head ${kStar}/${arr.length} (${(headFrac*100).toFixed(1)}%) • mass ${Math.min(cum,1).toFixed(2)}`, x+8, y+18);
  E.statK.textContent=`${kStar}/${arr.length}`; E.statMass.textContent=Math.min(cum,1).toFixed(2); ctx.restore(); }

function drawSky(){
  const {cx,cy,R}=projBase();
  const g=ctx.createRadialGradient(cx,cy,0,cx,cy,R*0.95); g.addColorStop(0,'#0b1222'); g.addColorStop(1,'#05080f'); ctx.fillStyle=g; ctx.fillRect(0,0,stage.clientWidth,stage.clientHeight);
  ctx.beginPath(); ctx.arc(cx,cy,R*0.9,0,Math.PI*2); ctx.strokeStyle='rgba(180,200,255,.15)'; ctx.lineWidth=2; ctx.stroke();
  ctx.strokeStyle='rgba(200,220,255,.08)'; ctx.lineWidth=1; for(let alt=10; alt<=80; alt+=10){ const P=projSky(0,alt); ctx.beginPath(); ctx.arc(P.cx,P.cy,P.rho,0,Math.PI*2); ctx.stroke(); }
  for(let az=0; az<360; az+=30){ const P0=projSky(az,0.1), P1=projSky(az,85); ctx.beginPath(); ctx.moveTo(P0.x,P0.y); ctx.lineTo(P1.x,P1.y); ctx.stroke(); }

  // intent vector glyph
  const vStart=projSky(lens.az,lens.alt); const vEnd=projSky(intent.bearing, Math.min(90, Math.max(0,intent.alt)));
  ctx.save(); ctx.strokeStyle='rgba(121,255,225,.85)'; ctx.lineWidth=2.5; ctx.setLineDash([8,6]); ctx.beginPath(); ctx.moveTo(vStart.x,vStart.y); ctx.lineTo(vEnd.x,vEnd.y); ctx.stroke(); ctx.setLineDash([]);
  ctx.fillStyle='rgba(121,255,225,.9)'; ctx.beginPath(); ctx.arc(vEnd.x,vEnd.y,5+3*intent.mag,0,Math.PI*2); ctx.fill();
  ctx.font='12px ui-monospace'; const lbl=`Intent → az ${Math.round(intent.bearing)}°, alt ${Math.round(intent.alt)}°, m=${intent.mag.toFixed(2)}, g=${intent.gain.toFixed(2)}`;
  const tw=ctx.measureText(lbl).width+10; ctx.fillStyle='rgba(16,20,30,.85)'; ctx.strokeStyle='#27304a'; ctx.lineWidth=1; ctx.beginPath(); ctx.roundRect(vEnd.x-tw/2, vEnd.y+10, tw, 20, 6); ctx.fill(); ctx.stroke(); ctx.fillStyle='#cfe8ff'; ctx.fillText(lbl, vEnd.x-tw/2+6, vEnd.y+25);
  ctx.restore();

  const ds=computeDS2Dual([...lockSet]); ctx.strokeStyle='rgba(159,122,234,.85)'; ctx.lineWidth=2; ctx.beginPath(); ctx.ellipse(cx,cy,R*0.28*(.6+.6*ds.g),R*0.28*(.6+.6*ds.v),0,0,Math.PI*2); ctx.stroke();
  renderPoints(); drawLensSky();
  E.statG.textContent=ds.g.toFixed(3); E.statV.textContent=ds.v.toFixed(3);
}

function lensPathSky(){
  const steps=180,alpha=lens.ang; ctx.beginPath();
  for(let i=0;i<=steps;i++){
    const t=2*Math.PI*i/steps; const col0=90-lens.alt, az0=lens.az;
    const col=Math.acos(Math.cos(toRad(alpha))*Math.cos(toRad(col0))+Math.sin(toRad(alpha))*Math.sin(toRad(col0))*Math.cos(t));
    const dAz=Math.atan2(Math.sin(t)*Math.sin(toRad(alpha))*Math.sin(toRad(col0)),Math.cos(toRad(alpha))-Math.cos(toRad(col))*Math.cos(toRad(col0)));
    const az=(az0+toDeg(dAz)+360)%360, alt=90-toDeg(col); const P=projSky(az,alt);
    if(i===0) ctx.moveTo(P.x,P.y); else ctx.lineTo(P.x,P.y);
  }
}
function drawLensSky(){
  const {scores,dsLocal}=lensScores(); const {cx,cy,R}=projBase();
  ctx.save(); ctx.beginPath(); ctx.arc(cx,cy,R*0.9,0,Math.PI*2); ctx.clip();
  ctx.save(); ctx.beginPath(); lensPathSky(); ctx.clip();
  for(let i=0;i<points.length;i++){
    const sAltAz={az:points[i].lon, alt:points[i].lat}; if(sAltAz.alt<0) continue;
    const P=projSky(sAltAz.az,sAltAz.alt); const val=scores[i]; if(val<=0) continue;
    const a=.25+.55*val; const col=(lens.mode==='infosophic')?`hsla(195,90%,60%,${a})`:`hsla(40,95%,60%,${a})`;
    ctx.beginPath(); ctx.fillStyle=col; ctx.arc(P.x,P.y,1.5+3*val,0,Math.PI*2); ctx.fill();
  }
  ctx.restore();
  ctx.lineWidth=2.2; ctx.setLineDash([6,4]); ctx.strokeStyle=(lens.mode==='infosophic')?'rgba(97,218,251,.9)':'rgba(251,191,36,.9)';
  ctx.beginPath(); lensPathSky(); ctx.stroke(); ctx.setLineDash([]);
  const Pc=projSky(lens.az,lens.alt);
  const label=(lens.mode==='infosophic')?'Infosophic sextant (∇⁻¹)':'Simulonic sextant (∇¹)⁻¹';
  const text=`${label} • r=${lens.ang}° • local ds²=${dsLocal.toFixed(3)}`;
  ctx.fillStyle='rgba(16,20,30,.85)'; ctx.strokeStyle='#27304a'; ctx.lineWidth=1; ctx.font='12px ui-monospace';
  const w=ctx.measureText(text).width+12,h=20; ctx.beginPath(); ctx.roundRect(Pc.x-w/2,Pc.y-30,w,h,6); ctx.fill(); ctx.stroke(); ctx.fillStyle='#cfe8ff'; ctx.fillText(text,Pc.x-w/2+6,Pc.y-16);
}

function renderPoints(){
  let posCount=0,negCount=0;
  for(let i=0;i<points.length;i++){
    const P=projSky(points[i].lon,points[i].lat); if(!P.visible) continue;
    const w=weights[i]||0; const rPt=1.2+3.8*w; const locked=lockSet.has(i);
    const dimIdx=DIMENSIONS.indexOf(points[i].dim); const baseHue=(dimIdx*37)%360; const hue=(points[i].mood>=0)?(baseHue*0.7+120*0.3):(baseHue*0.7+0*0.3); const alpha=0.55+0.35*w;
    ctx.beginPath(); ctx.fillStyle=locked?`hsl(160 90% 60% / .95)`: `hsl(${hue} 80% 60% / ${alpha})`; ctx.strokeStyle=locked?'rgba(110,231,166,.85)':(points[i].mood>=0?'rgba(110,231,166,.28)':'rgba(248,113,113,.28)'); ctx.lineWidth=locked?1.4:0.8;
    ctx.arc(P.x,P.y,rPt*(locked?1.25:1.0),0,Math.PI*2); ctx.fill(); ctx.stroke();
    if(locked){ctx.beginPath(); ctx.setLineDash([3,3]); ctx.strokeStyle='rgba(110,231,166,.25)'; ctx.arc(P.x,P.y,rPt*2.0,0,Math.PI*2); ctx.stroke(); ctx.setLineDash([]);} 
    if(points[i].mood>=0) posCount++; else negCount++;
  }
  E.statPos.textContent=posCount; E.statNeg.textContent=negCount;
}

/* ===== Auto-sextant targeting ===== */
function vecToAzAlt(v){ const alt=Math.asin(Math.max(-1,Math.min(1,v.z))); const az=(Math.atan2(v.x,v.y)+2*Math.PI)%(2*Math.PI); return {az:toDeg(az), alt:toDeg(alt)}; }
function computeSkyAutoTarget(){
  let vx=0,vy=0,vz=0, wsum=0;
  const add = (az,alt,w)=>{ const v=skyVec(az,alt); vx+=v.x*w; vy+=v.y*w; vz+=v.z*w; wsum+=w; };
  const consider = (i,wExtra=0)=>{ const w=(weights[i]||0)+wExtra; if(w<=0) return; add(points[i].lon, points[i].lat, w); };
  if(lockSet.size>0){ for(const i of lockSet) consider(i,0.6); }
  else { const idx=[...points.map((p,i)=>[weights[i],i])].sort((a,b)=>b[0]-a[0]).slice(0,Math.max(20,Math.floor(points.length*0.05))).map(x=>x[1]); for(const i of idx) consider(i,0); }
  if(wsum<=0){ auto.targetAz=null; auto.targetAlt=null; return; }
  const vnorm=Math.hypot(vx,vy,vz)||1; const v={x:vx/vnorm,y:vy/vnorm,z:vz/vnorm}; const tar=vecToAzAlt(v);
  auto.targetAz=tar.az; auto.targetAlt=Math.max(0, Math.min(90, tar.alt));
}
function stepLensTowardTarget(dt){
  if(!auto.enabled || auto.targetAz==null || auto.targetAlt==null) return;
  if(lens.dragging || globe.dragging || auto.cooldown>0){ auto.cooldown=Math.max(0, auto.cooldown-dt); return; }
  const speed = auto.speed;
  let dAz = ((auto.targetAz - lens.az + 540) % 360) - 180;
  lens.az = (lens.az + dAz*speed + 360) % 360;
  lens.alt += (auto.targetAlt - lens.alt) * speed;
  lens.alt = Math.max(0, Math.min(90, lens.alt));
}

/* ===== Runtime (minimal) ===== */
function contextSnapshot(){ const ds=computeDS2Dual([...lockSet]); const head=headStatsForTarget(cfg.targetMass);
  return {observer:{lon:globe.lon0,lat:globe.lat0}, lens:{kind:lens.mode,az:lens.az,alt:lens.alt,radiusDeg:lens.ang}, intent:{bearing:intent.bearing,alt:intent.alt,mag:intent.mag,gain:intent.gain},
    ds2:{green:+ds.g.toFixed(6),vacuum:+ds.v.toFixed(6)}, tau:+cfg.paretoTau.toFixed(6), head:{k:head.k,mass:+head.mass.toFixed(6)}, selected:{indices:[...lockSet],count:lockSet.size}, pointsCount:points.length, timestamp:new Date().toISOString()};}
function executeSimuLang(){ const {scores}=lensScores(); let sum=0,n=0; for(let i=0;i<scores.length;i++){ if(scores[i]>0){sum+=scores[i];n++;}} const lensIntensity=(n?sum/n:0);
  return {cfgUsed:{execMode:cfg.execMode,execMetric:'lens_intensity'}, result:{metric:'lens_intensity',value:+lensIntensity.toFixed(6)}};}
function appendLog(ctxObj,exec){ const line=document.createElement('div'); line.className='line'; const p1=document.createElement('div'); p1.innerHTML=`<span class="tag exec">EXEC</span> <span class="mono">${ctxObj.timestamp}</span>`; const pre=document.createElement('pre'); pre.textContent=JSON.stringify({context:ctxObj,...exec},null,2); E.runtimeLog.prepend(line); line.appendChild(p1); line.appendChild(pre); }
function maybeAutoExec(){ if(!E.chkAutoExec.checked) return; const c=contextSnapshot(); const ex=executeSimuLang(c); appendLog(c,ex); }

/* ===== Render loop ===== */
let lastT=performance.now();
function render(t){
  const dt=Math.min(0.1,(t-lastT)/1000); lastT=t;
  if(cfg.autoPareto && points.length>0) autoAdjustTau(dt);
  stepLensTowardTarget(dt);
  ctx.clearRect(0,0,stage.clientWidth,stage.clientHeight);
  ensurePoints();
  drawSky();
  drawParetoBar();
  E.statL.textContent=lockSet.size;
  requestAnimationFrame(render);
}

/* ===== Interaction (sky only) ===== */
stage.addEventListener('mousedown', e=>{
  const r=stage.getBoundingClientRect(); const x=e.clientX-r.left, y=e.clientY-r.top;
  const inv=invSky(x,y); if(inv){ const ang= Math.acos( Math.max(-1, Math.min(1, dot(skyVec(inv.az,inv.alt), skyVec(lens.az, lens.alt)) )) ); if(toDeg(ang)<=lens.ang){ lens.dragging=true; } else { globe.dragging=true; globe.lastX=x; globe.lastY=y; } }
});
addEventListener('mouseup', ()=>{ const dragged=lens.dragging; globe.dragging=false; lens.dragging=false; if(dragged){ auto.cooldown=0.25; computeSkyAutoTarget(); maybeAutoExec(); } });
addEventListener('mousemove', e=>{
  const r=stage.getBoundingClientRect(); const x=e.clientX-r.left, y=e.clientY-r.top;
  if(globe.dragging){ const dx=x-globe.lastX, dy=y-globe.lastY; globe.lon0=((globe.lon0-dx*0.2+540)%360)-180; globe.lat0=Math.max(-80,Math.min(80,globe.lat0+dy*0.2)); globe.lastX=x; globe.lastY=y; }
  else if(lens.dragging){ const inv=invSky(x,y); if(inv){ lens.az=inv.az; lens.alt=Math.max(0,Math.min(90,inv.alt)); } }
});
stage.addEventListener('click', e=>{
  if(globe.dragging||lens.dragging) return;
  const r=stage.getBoundingClientRect(); const x=e.clientX-r.left,y=e.clientY-r.top; let best=-1,bd=1e9;
  for(let i=0;i<points.length;i++){
    const P=projSky(points[i].lon,points[i].lat); if(!P.visible) continue; const d=(P.x-x)*(P.x-x)+(P.y-y)*(P.y-y); if(d<bd){bd=d; best=i;}
  }
  if(best>=0){ if(lockSet.has(best)) lockSet.delete(best); else lockSet.add(best); computeSkyAutoTarget(); maybeAutoExec(); }
});

/* ===== Controls ===== */
E.rngObsLon.addEventListener('input', e=>{ globe.lon0=parseFloat(e.target.value); E.labObsLon.textContent=`${Math.round(globe.lon0)}°`; buildART(); ensurePoints(); computeSkyAutoTarget(); });
E.rngObsLat.addEventListener('input', e=>{ globe.lat0=parseFloat(e.target.value); E.labObsLat.textContent=`${Math.round(globe.lat0)}°`; buildART(); ensurePoints(); computeSkyAutoTarget(); });

E.rngTau.addEventListener('input', e=>{ cfg.paretoTau=parseFloat(e.target.value); E.labTau.textContent=cfg.paretoTau.toFixed(2); E.statT.textContent=cfg.paretoTau.toFixed(2); recomputeWeights(); computeSkyAutoTarget(); });
E.chkAutoPareto.addEventListener('change', e=>{ cfg.autoPareto=e.target.checked; });
E.rngTargetMass.addEventListener('input', e=>{ cfg.targetMass=parseFloat(e.target.value); E.labTargetMass.textContent=cfg.targetMass.toFixed(2); computeSkyAutoTarget(); });
E.rngNu.addEventListener('input', e=>{ cfg.artNu=parseInt(e.target.value,10); E.labNu.textContent=cfg.artNu; buildART(); ensurePoints(); computeSkyAutoTarget(); });
E.rngPts.addEventListener('input', e=>{ cfg.artPoints=parseInt(e.target.value,10); E.labPts.textContent=cfg.artPoints; buildART(); ensurePoints(); computeSkyAutoTarget(); });
E.rngMood.addEventListener('input', e=>{ cfg.moodStrength=parseFloat(e.target.value); E.labMood.textContent=cfg.moodStrength.toFixed(2); buildART(); ensurePoints(); computeSkyAutoTarget(); });
E.btnShuffle.addEventListener('click', ()=>{ seed=(seed*1664525+1013904223)>>>0; buildART(); ensurePoints(); computeSkyAutoTarget(); maybeAutoExec(); });
E.btnClear.addEventListener('click', ()=>{ lockSet.clear(); computeSkyAutoTarget(); maybeAutoExec(); });
E.btnLensMode.addEventListener('click', ()=>{ lens.mode = lens.mode==='infosophic' ? 'simulonic' : 'infosophic'; E.btnLensMode.textContent = (lens.mode==='infosophic' ? 'Lens: Infosophic (I)' : 'Lens: Simulonic (S)'); maybeAutoExec(); });
addEventListener('keydown', (e)=>{ if(e.key.toLowerCase()==='i'){ lens.mode='infosophic'; E.btnLensMode.textContent='Lens: Infosophic (I)'; maybeAutoExec(); }
                                   if(e.key.toLowerCase()==='s'){ lens.mode='simulonic'; E.btnLensMode.textContent='Lens: Simulonic (S)'; maybeAutoExec(); }});
E.rngLensR.addEventListener('input', e=>{ lens.ang=parseInt(e.target.value,10); E.labLensR.textContent=`${lens.ang}°`; buildART(); ensurePoints(); computeSkyAutoTarget(); });
E.chkAutoSextant.addEventListener('change', e=>{ auto.enabled=e.target.checked; if(auto.enabled){ computeSkyAutoTarget(); } });
E.rngAutoSpeed.addEventListener('input', e=>{ auto.speed=parseFloat(e.target.value); E.labAutoSpeed.textContent=auto.speed.toFixed(2); });

// Intent vector controls
E.rngBearing.addEventListener('input', e=>{ intent.bearing=parseFloat(e.target.value); E.labBearing.textContent=`${Math.round(intent.bearing)}°`; buildART(); ensurePoints(); computeSkyAutoTarget(); });
E.rngAlt.addEventListener('input', e=>{ intent.alt=parseFloat(e.target.value); E.labAlt.textContent=`${Math.round(intent.alt)}°`; buildART(); ensurePoints(); computeSkyAutoTarget(); });
E.rngMag.addEventListener('input', e=>{ intent.mag=parseFloat(e.target.value); E.labMag.textContent=intent.mag.toFixed(2); buildART(); ensurePoints(); computeSkyAutoTarget(); });
E.rngGain.addEventListener('input', e=>{ intent.gain=parseFloat(e.target.value); E.labGain.textContent=intent.gain.toFixed(2); buildART(); ensurePoints(); computeSkyAutoTarget(); });

E.btnApply.addEventListener('click', ()=>{ const p=parseSimuLang(E.simTxt.value); cfg={...cfg, ...p}; intent.bearing=p.intBearing; intent.alt=p.intAlt; intent.mag=p.intMag; intent.gain=p.intGain; syncControls(); buildART(); ensurePoints(); computeSkyAutoTarget(); maybeAutoExec(); });
E.btnReset.addEventListener('click', ()=>{ E.simTxt.value=defaultSimuLang(); cfg=parseSimuLang(E.simTxt.value); intent.bearing=cfg.intBearing; intent.alt=cfg.intAlt; intent.mag=cfg.intMag; intent.gain=cfg.intGain; syncControls(); buildART(); ensurePoints(); computeSkyAutoTarget(); maybeAutoExec(); });
E.btnRun.addEventListener('click', ()=>{ const c=contextSnapshot(); const ex=executeSimuLang(c); appendLog(c,ex); });

/* ===== Init ===== */
function init(){
  E.simTxt.value=defaultSimuLang();
  cfg=parseSimuLang(E.simTxt.value);
  syncControls();
  buildOutlookGrid();
  buildART();
  ensurePoints();
  computeSkyAutoTarget();
  requestAnimationFrame(render);
}
init();
</script>
</body>
</html>
