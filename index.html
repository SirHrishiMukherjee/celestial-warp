<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Celestial • Intent Sextant + WarpDock • Mnality</title>
<style>
  :root{--bg:#0f1115;--panel:#161a22;--card:#1c2230;--text:#e8eef7;--muted:#9bb0c8;--accent:#61dafb;--good:#6ee7a6;--warn:#fbbf24;--grid:#2a3242;--hl:#9f7aea;--bad:#f87171}
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#0c0f14,#0f1115);color:var(--text);font:14px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif}
  header{position:sticky;top:0;z-index:20;display:flex;align-items:center;justify-content:space-between;padding:12px 16px;border-bottom:1px solid #202636;background:rgba(22,26,34,.85);backdrop-filter:blur(6px)}
  .brand{display:flex;gap:10px;align-items:center}
  .logo{width:36px;height:36px;border-radius:10px;background:radial-gradient(circle at 30% 30%,#7cfcff,#4c50ff 45%,#1f1340 70%);box-shadow:0 0 24px rgba(97,218,251,.35),inset 0 0 18px rgba(255,255,255,.12)}
  .title{font-weight:700}.sub{font-size:12px;color:var(--muted)}

  /* ---- 3-col grid layout (adds Mnality card) ---- */
  #app{
    display:grid;gap:14px;padding:12px;
    grid-template-columns:1fr 1fr 1fr;
    grid-template-rows:minmax(440px,40vh) auto;
    grid-template-areas:
      "sky warp mn"
      "controls controls controls";
  }
  #skyCard{grid-area:sky}
  #warpCard{grid-area:warp}
  #mnalityCard{grid-area:mn}
  #controlsRow{grid-area:controls; display:grid; gap:14px; grid-template-columns:1fr 1fr;}
  @media (max-width: 1400px){
    #app{grid-template-columns:1fr; grid-template-rows:auto; grid-template-areas:"sky" "warp" "mn" "controls";}
    #controlsRow{grid-template-columns:1fr}
  }

  /* ---- Cards / visuals ---- */
  .card{background:rgba(22,26,34,.9);border:1px solid #232a3a;border-radius:14px;box-shadow:0 10px 30px rgba(0,0,0,.25),inset 0 0 0 1px rgba(255,255,255,.02)}
  .visual{position:relative;min-height:100%;height:100%}
  .visualPad{padding:10px;height:100%}
  .stageWrap{position:relative;width:100%;height:100%}
  canvas{display:block;width:100%;height:100%;background:linear-gradient(180deg,#0b0e17,#0a0d14)}

  /* Overlays that stay on the sky canvas (legend/stats) */
  .legend{position:absolute;right:12px;top:12px;background:rgba(16,20,30,.78);padding:8px 10px;border:1px solid #27304a;border-radius:10px;font-size:12px}
  .pill{display:inline-block;padding:2px 8px;border-radius:999px;margin:2px 2px;border:1px solid #2a3250}
  .pill.blue{background:rgba(97,218,251,.12);color:#bdefff}
  .pill.green{background:rgba(110,231,166,.12);color:#c7f8de}
  .pill.purple{background:rgba(159,122,234,.12);color:#e1d1ff}
  .pill.gold{background:rgba(251,191,36,.12);color:#ffe3a3}
  .pill.pos{background:rgba(110,231,166,.12);color:#bdf8dc;border-color:#245c41}
  .pill.neg{background:rgba(248,113,113,.12);color:#ffd1d1;border-color:#5c2424}
  .stats{position:absolute;right:12px;bottom:12px;background:rgba(16,20,30,.78);padding:10px;border:1px solid #27304a;border-radius:10px;font-size:12px}
  .statLine{display:flex;justify-content:space-between;gap:12px;margin:4px 0}
  .muted{color:var(--muted)}

  /* ---- Controls styling (bottom row) ---- */
  .panel{border:1px solid #232a3a;background:rgba(22,26,34,.9);border-radius:14px;padding:12px;box-shadow:0 10px 30px rgba(0,0,0,.25),inset 0 0 0 1px rgba(255,255,255,.02)}
  .panel .h{font-size:12px;text-transform:uppercase;letter-spacing:.12em;color:var(--muted);margin:2px 0 8px}
  .row{display:flex;gap:10px;align-items:center;margin:8px 0}
  .row input[type="range"]{flex:1}
  .btn{padding:7px 10px;background:var(--card);border:1px solid #2a3147;color:var(--text);border-radius:10px;cursor:pointer;font-size:13px}
  .btn:hover{border-color:#3a425e}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;font-size:12px}
  textarea.code{width:100%;min-height:150px;resize:vertical;border:1px solid #283048;border-radius:12px;background:#151a26;color:#e8eef7;padding:10px;outline:none}
  .outlookGrid{display:grid;grid-template-columns:1fr auto;gap:6px;background:rgba(21,26,38,.7);border:1px solid #27304a;border-radius:10px;padding:8px;margin:8px 0}
  .toggle{padding:4px 8px;border-radius:999px;border:1px solid #2a3147;cursor:pointer;font-size:12px;background:linear-gradient(180deg,#1f2a44,#1a2440)}
  .toggle.pos{border-color:#2b6b54}.toggle.neg{border-color:#6b2b2b}
  .swatch{display:inline-block;width:10px;height:10px;border-radius:50%;margin-right:6px;vertical-align:middle}
  .note{font-size:11px;color:var(--muted);margin-top:6px;line-height:1.35}

  /* WarpDock title row */
  #warpHostTitle{display:flex;align-items:center;gap:10px;margin:6px 0 10px}
  #warpHostTitle .dot{width:7px;height:7px;border-radius:50%;background:#79ffe1;box-shadow:0 0 12px rgba(121,255,225,.45)}
  #warpHostTitle .t{font-weight:800;letter-spacing:.4px}

  /* ===== Mnality Card ===== */
  .mnCardHead{display:flex;align-items:center;justify-content:space-between;padding:0px 0px;border-bottom:1px solid #232a3a}
  .mnTitle{font-weight:800}
  #mnSymbolWrap{display:flex;align-items:center;justify-content:center;height:340px;padding:8px}
  #mn_symbol{position:relative;width:320px;height:420px;display:flex;align-items:flex-end;justify-content:center;cursor:pointer;transform:rotate(180deg)}
  .mn_input{position:absolute;bottom:0;width:6px;height:150px;background:#6ef;z-index:2;border-radius:2px}
  .mn_out{position:absolute;width:4px;height:110px;background:#89a;border-radius:50%;transform-origin:top center;transition:background .3s, box-shadow .3s}
  .mn_lit{background:#6ef !important;box-shadow:0 0 12px #6ef}
  #mnCtrls .row label{min-width:170px}
  #mnFooter{position:relative;text-align:center;color:#aab3c9;font-size:12px;margin-top:8px}
  #mn_yearFlash{position:absolute;left:50%;transform:translateX(-50%);font-size:28px;opacity:0;pointer-events:none}
</style>
</head>
<body>
<header>
  <div class="brand">
    <div class="logo"></div>
    <div>
      <div class="title">Celestial • Simulonic × Infosophic Lab</div>
      <div class="sub">Sky dome • Lens • Dynamic Pareto • SimuLang • Auto Sextant • CII Intent Vector</div>
    </div>
  </div>
  <div class="sub">Infosophic: Gösta Greimel • Simulonic: Hrishi Mukherjee • Integration: Greimel & Mukherjee • OBT: Oliver Boeschenstein</div>
</header>

<div id="app">
  <!-- Upper left: Skydome -->
  <div id="skyCard" class="card visual">
    <div class="visualPad">
      <div class="stageWrap" id="stageWrap">
        <canvas id="stage"></canvas>

        <!-- Keep visual legend & stats over the canvas -->
        <div class="legend">
          <span class="pill blue">ART t-field</span>
          <span class="pill green">Lock-on</span>
          <span class="pill purple">Infosophic ⇄ Simulonic</span>
          <span class="pill gold">ds² gauges</span>
          <span class="pill pos">Optimistic</span>
          <span class="pill neg">Pessimistic</span>
        </div>
        <div class="stats" id="statsBox">
          <div class="statLine"><span class="muted">ds² (Green)</span><span class="mono" id="statG">0.000</span></div>
          <div class="statLine"><span class="muted">ds² (Vacuum)</span><span class="mono" id="statV">0.000</span></div>
          <div class="statLine"><span class="muted">Locked</span><span class="mono" id="statL">0</span></div>
          <div class="statLine"><span class="muted">τ</span><span class="mono" id="statT">0.00</span></div>
          <div class="statLine"><span class="muted">Head k/N</span><span class="mono" id="statK">0/0</span></div>
          <div class="statLine"><span class="muted">Head mass</span><span class="mono" id="statMass">0.00</span></div>
          <div class="statLine"><span class="muted">Optimistic</span><span class="mono" id="statPos">0</span></div>
          <div class="statLine"><span class="muted">Pessimistic</span><span class="mono" id="statNeg">0</span></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Upper middle: Warp stage -->
  <div id="warpCard" class="card visual">
    <div class="visualPad">
      <div id="warpHostTitle"><div class="dot"></div>
        <div class="t">WarpDock • New Canada Warp Drive</div>
        <div class="sub" style="margin-left:auto;">CII routing • particle flux • intent bias</div>
      </div>
      <div id="warpMount"></div>
    </div>
  </div>

  <!-- Upper right: Mnality -->
  <div id="mnalityCard" class="card">
    <div class="mnCardHead">
      <div class="mnTitle">Simulon Mnality</div>
      <div class="sub">Dual curvilinear outputs • 2→256</div>
    </div>
    <div id="mnSymbolWrap">
      <div id="mn_symbol" title="Toggle symbol">
        <div class="mn_input"></div>
      </div>
    </div>
    <div id="mnCtrls" class="panel" style="margin:10px">
      <div class="h">Mnality Controls</div>
      <div class="row">
        <label>Output Dimensionality: <span id="mn_strandCount" class="mono">3</span></label>
      </div>
      <div class="row">
        <input type="range" id="mn_range" min="2" max="256" value="3" />
      </div>
      <div class="row">
        <input type="number" id="mn_number" min="2" max="256" value="3" style="width:110px" />
        <button class="btn" id="mn_light">Light Random Strand</button>
      </div>
      <div id="mnFooter">
        <span id="mn_copyright">&copy; Hrishi Mukherjee Horizons 2028</span>
        <div id="mn_yearFlash">2028</div>
      </div>
      <div class="note">Tip: click strands to light them; footer flashes the active year using the strand color.</div>
    </div>
  </div>

  <!-- Bottom row: all controls (left = Sextant/Sky; right = Warp) -->
  <div id="controlsRow">
    <div id="ctrlPanel" class="panel">
      <div class="h">Observer & Sextant</div>
      <div class="row">
        <span class="muted">Observer Lon</span><input id="rngObsLon" type="range" min="-180" max="180" step="1"><span class="mono" id="labObsLon"></span>
      </div>
      <div class="row">
        <span class="muted">Observer Lat</span><input id="rngObsLat" type="range" min="-80" max="80" step="1"><span class="mono" id="labObsLat"></span>
      </div>
      <div class="row">
        <div class="row" style="flex:1">
          <div class="row" style="gap:12px;flex-wrap:wrap">
            <label class="muted" style="display:flex;align-items:center;gap:8px"><input id="chkAutoSextant" type="checkbox"> Auto Sextant Lock</label>
            <span class="muted">Lock speed</span>
            <input id="rngAutoSpeed" type="range" min="0.02" max="0.5" step="0.01" value="0.15" style="flex:1">
            <span class="mono" id="labAutoSpeed">0.15</span>
          </div>
        </div>
      </div>

      <div class="h">CII Intent Vector (sky)</div>
      <div class="row"><span class="muted">Bearing (az°)</span><input id="rngBearing" type="range" min="0" max="360" step="1"><span class="mono" id="labBearing"></span></div>
      <div class="row"><span class="muted">Elevation (alt°)</span><input id="rngAlt" type="range" min="0" max="90" step="1"><span class="mono" id="labAlt"></span></div>
      <div class="row"><span class="muted">Magnitude</span><input id="rngMag" type="range" min="0" max="1" step="0.01" value="0.7"><span class="mono" id="labMag">0.70</span></div>
      <div class="row"><span class="muted">Gain</span><input id="rngGain" type="range" min="0" max="2" step="0.01" value="0.6"><span class="mono" id="labGain">0.60</span></div>

      <div class="h">Dynamic Pareto & ART</div>
      <div class="row"><span class="muted">τ (manual)</span><input id="rngTau" type="range" min="0.05" max="1.5" step="0.01"><span class="mono" id="labTau"></span></div>
      <div class="row"><label class="muted" style="display:flex;align-items:center;gap:8px"><input id="chkAutoPareto" type="checkbox" /> Auto Pareto (keep ~20% head for target mass)</label></div>
      <div class="row"><span class="muted">Target head mass</span><input id="rngTargetMass" type="range" min="0.50" max="0.95" step="0.01" style="flex:1"><span class="mono" id="labTargetMass"></span></div>

      <div class="row"><span class="muted">ν (DOF)</span><input id="rngNu" type="range" min="1" max="12" step="1"><span class="mono" id="labNu"></span></div>
      <div class="row"><span class="muted">Points</span><input id="rngPts" type="range" min="60" max="3000" step="20"><span class="mono" id="labPts"></span></div>
      <div class="row"><span class="muted">Mood Strength</span><input id="rngMood" type="range" min="0" max="2" step="0.05" style="flex:1"><span class="mono" id="labMood"></span></div>
      <div class="row"><button class="btn" id="btnShuffle">Shuffle Seed</button><button class="btn" id="btnClear">Clear Lock-ons</button></div>

      <div class="h">Outlooks (per dimension)</div>
      <div id="outlookGrid" class="outlookGrid"></div>
      <div class="note">Simulation labels only—abstract categories to test geometry. No real-world judgments are implied.</div>

      <div class="h">Lens</div>
      <div class="row">
        <button class="btn" id="btnLensMode">Lens: Infosophic (I)</button>
        <span class="muted">Angular radius</span>
        <input id="rngLensR" type="range" min="5" max="60" step="1" style="flex:1;max-width:240px">
        <span class="mono" id="labLensR">20°</span>
      </div>

      <div class="h">SimuLang Hook (mini) + Runtime</div>
      <textarea id="simTxt" class="code mono" spellcheck="false"></textarea>
      <div class="row">
        <label class="muted" style="display:flex;align-items:center;gap:8px"><input id="chkAutoExec" type="checkbox"> Auto-exec on lock & lens</label>
        <button class="btn" id="btnRun">Run Now</button>
        <button class="btn" id="btnReset">Reset</button>
      </div>
      <div id="runtimeLog" class="log" style="max-height:180px;overflow:auto;border:1px solid #283048;border-radius:12px;background:#0f1524;padding:8px;font:12px/1.5 ui-monospace;color:#cfe8ff"></div>
      <div class="row"><button class="btn" id="btnApply">Apply SimuLang</button></div>
    </div>

    <div id="warpControls" class="panel">
      <!-- Filled by script with WarpDock controls -->
    </div>
  </div>
</div>

<script>
/* ====== Canvas utilities & sizing ====== */
const $ = id => { const el = document.getElementById(id); if(!el) throw new Error('Missing element '+id); return el; };
const stage=$('stage'), ctx=stage.getContext('2d');

function fitCanvas(){
  const pad = $('stageWrap');
  const dpr=Math.max(1,devicePixelRatio||1);
  stage.width=Math.floor(pad.clientWidth*dpr);
  stage.height=Math.floor(pad.clientHeight*dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
addEventListener('resize',fitCanvas,{passive:true});

/* ===== roundRect polyfill ===== */
if (!CanvasRenderingContext2D.prototype.roundRect) {
  CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
    const rr = Array.isArray(r) ? r : [r, r, r, r].map(v => Math.max(0, v || 0));
    const [r1, r2, r3, r4] = rr;
    this.beginPath();
    this.moveTo(x + r1, y);
    this.lineTo(x + w - r2, y);
    this.quadraticCurveTo(x + w, y, x + w, y + r2);
    this.lineTo(x + w, y + h - r3);
    this.quadraticCurveTo(x + w, y + h, x + w - r3, y + h);
    this.lineTo(x + r4, y + h);
    this.quadraticCurveTo(x, y + h, x, y + h - r4);
    this.lineTo(x, y + r1);
    this.quadraticCurveTo(x, y, x + r1, y);
  };
}

/* ===== DOM refs for controls ===== */
const E={
  rngObsLon:$('rngObsLon'), labObsLon:$('labObsLon'),
  rngObsLat:$('rngObsLat'), labObsLat:$('labObsLat'),
  chkAutoSextant:$('chkAutoSextant'), rngAutoSpeed:$('rngAutoSpeed'), labAutoSpeed:$('labAutoSpeed'),
  rngBearing:$('rngBearing'), labBearing:$('labBearing'),
  rngAlt:$('rngAlt'), labAlt:$('labAlt'),
  rngMag:$('rngMag'), labMag:$('labMag'),
  rngGain:$('rngGain'), labGain:$('labGain'),
  rngTau:$('rngTau'), labTau:$('labTau'), chkAutoPareto:$('chkAutoPareto'), rngTargetMass:$('rngTargetMass'), labTargetMass:$('labTargetMass'),
  rngNu:$('rngNu'), labNu:$('labNu'), rngPts:$('rngPts'), labPts:$('labPts'), rngMood:$('rngMood'), labMood:$('labMood'),
  btnShuffle:$('btnShuffle'), btnClear:$('btnClear'), outlookGrid:$('outlookGrid'),
  simTxt:$('simTxt'), btnApply:$('btnApply'), btnReset:$('btnReset'), chkAutoExec:$('chkAutoExec'), btnRun:$('btnRun'), runtimeLog:$('runtimeLog'),
  btnLensMode:$('btnLensMode'), rngLensR:$('rngLensR'), labLensR:$('labLensR'),
  statG:$('statG'), statV:$('statV'), statL:$('statL'), statT:$('statT'), statK:$('statK'), statMass:$('statMass'), statPos:$('statPos'), statNeg:$('statNeg')
};

/* ===== Math & helpers ===== */
const toRad=d=>d*Math.PI/180, toDeg=r=>r*180/Math.PI;
function rng(seed){let t=seed>>>0; return ()=>{t+=0x6D2B79F5; let r=Math.imul(t^(t>>>15),1|t); r^=r+Math.imul(r^(r>>>7),61|r); return ((r^(r>>>14))>>>0)/4294967296;};}
function randn(r){let u=1-r(),v=1-r(); return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);} 
function chiSquare(df,r){let s=0;for(let i=0;i<df;i++){const z=randn(r); s+=z*z;} return s;}
function studentT(df,r){const z=randn(r); return z/Math.sqrt(chiSquare(df,r)/df);} 
function softmax(a,t=1){const m=Math.max(...a); const ex=a.map(v=>Math.exp((v-m)/Math.max(1e-6,t))); const s=ex.reduce((x,y)=>x+y,0); return ex.map(e=>e/s);} 

/* ===== Sky projection ===== */
function projBase(){const R=Math.min(stage.clientWidth,stage.clientHeight)*0.42;const cx=stage.clientWidth/2,cy=stage.clientHeight/2;return {R,cx,cy};}
function projSky(az,alt){const {R,cx,cy}=projBase();const k=R*0.9/90;const r=(90-alt)*k;const th=toRad(az);const x=cx+r*Math.sin(th),y=cy-r*Math.cos(th);return {x,y,visible:alt>=0,rho:r,cx,cy,R:R*0.9};}
function invSky(x,y){const {R,cx,cy}=projBase();const k=R*0.9/90;const dx=x-cx,dy=y-cy;const r=Math.hypot(dx,dy);if(r>R*0.9+2) return null;const az=((toDeg(Math.atan2(dx,-dy))+360)%360);const alt=90-r/k;return {az,alt};}
function skyVec(azDeg,altDeg){ const az=toRad(azDeg), alt=toRad(altDeg); const c=Math.cos(alt); return {x:c*Math.sin(az), y:c*Math.cos(az), z:Math.sin(alt)}; }
function dot(a,b){return a.x*b.x+a.y*b.y+a.z*b.z;}

/* ===== State ===== */
const DIMENSIONS=['Dynasty','Empire','Family','Field', 'Star'];
let outlook=Object.fromEntries(DIMENSIONS.map(d=>[d,+1]));
let seed=42, points=[], weights=[], lockSet=new Set();
const globe={lon0:0,lat0:15,dragging:false,lastX:0,lastY:0};
const lens={az:0,alt:60, ang:20, mode:'infosophic', dragging:false};
const auto={enabled:false, speed:0.15, targetAz:null, targetAlt:null, cooldown:0};
const intent={bearing:0, alt:45, mag:0.7, gain:0.6};
let cfg;
E.labAutoSpeed.textContent=auto.speed.toFixed(2);

/* ===== SimuLang ===== */
function defaultSimuLang(){return `# SimuLang (runtime)
pareto.tau = 0.55
quality.q = 1.00
art.nu = 3
art.points = 900
lockon.k = 8
mood.strength = 1.0
auto.pareto = true
target.mass = 0.80
# Intent Vector (sky)
intent.bearing = 0
intent.alt = 45
intent.magnitude = 0.70
intent.gain = 0.60
# observer
observer.lon = 0
observer.lat = 15
# runtime:
execute.mode = auto
execute.metric = lens_intensity
`; }
function parseSimuLang(src){
  const c={paretoTau:0.55,qualityQ:1.0,artNu:3,artPoints:900,lockTopK:8,moodStrength:1.0,autoPareto:true,targetMass:0.80,obsLon:0,obsLat:15,intBearing:0,intAlt:45,intMag:0.7,intGain:0.6,execMode:'auto',execMetric:'lens_intensity'};
  for(const raw of src.split('\n')){const l=raw.trim(); if(!l||l.startsWith('#')) continue; const m=l.match(/^([a-z._]+)\s*=\s*(.+)$/i); if(!m) continue; const k=m[1].toLowerCase(), v=m[2].trim();
    if(k==='pareto.tau') c.paretoTau=parseFloat(v);
    else if(k==='quality.q') c.qualityQ=parseFloat(v);
    else if(k==='art.nu') c.artNu=Math.max(1,parseInt(v));
    else if(k==='art.points') c.artPoints=Math.max(10,Math.min(5000,parseInt(v)));
    else if(k==='lockon.k') c.lockTopK=Math.max(0,parseInt(v));
    else if(k==='mood.strength') c.moodStrength=Math.max(0,parseFloat(v));
    else if(k==='auto.pareto') c.autoPareto=(v.toLowerCase()==='true');
    else if(k==='target.mass') c.targetMass=Math.min(0.95,Math.max(0.5,parseFloat(v)));
    else if(k==='intent.bearing') c.intBearing=parseFloat(v);
    else if(k==='intent.alt') c.intAlt=parseFloat(v);
    else if(k==='intent.magnitude') c.intMag=parseFloat(v);
    else if(k==='intent.gain') c.intGain=parseFloat(v);
    else if(k==='observer.lon') c.obsLon=parseFloat(v);
    else if(k==='observer.lat') c.obsLat=parseFloat(v);
    else if(k==='execute.mode') c.execMode=v.toLowerCase();
    else if(k==='execute.metric') c.execMetric=v.toLowerCase();
  }
  if(!Number.isFinite(c.artPoints)||c.artPoints<10) c.artPoints=900;
  if(!Number.isFinite(c.artNu)||c.artNu<1) c.artNu=3;
  if(!Number.isFinite(c.paretoTau)||c.paretoTau<=0) c.paretoTau=0.55;
  if(!Number.isFinite(c.qualityQ)||c.qualityQ<=0) c.qualityQ=1.0;
  if(!Number.isFinite(c.intMag)) c.intMag=0.7;
  if(!Number.isFinite(c.intGain)) c.intGain=0.6;
  if(!Number.isFinite(c.intBearing)) c.intBearing=0;
  if(!Number.isFinite(c.intAlt)) c.intAlt=45;
  if(!Number.isFinite(c.obsLon)) c.obsLon=0;
  if(!Number.isFinite(c.obsLat)) c.obsLat=15;
  return c;
}

/* ===== UI sync ===== */
function hueForDim(i){return (i*37)%360;}
function buildOutlookGrid(){
  E.outlookGrid.innerHTML='';
  DIMENSIONS.forEach((d,i)=>{
    const label=document.createElement('div'); const sw=document.createElement('span'); sw.className='swatch'; sw.style.background=`hsl(${hueForDim(i)} 80% 60%)`;
    label.appendChild(sw); label.appendChild(document.createTextNode(d));
    const btn=document.createElement('button'); const isPos=outlook[d]>=0;
    btn.className='toggle '+(isPos?'pos':'neg'); btn.textContent=isPos?'Optimistic':'Pessimistic';
    btn.addEventListener('click',()=>{outlook[d]=(outlook[d]>=0)?-1:+1; buildART(); ensurePoints(); computeSkyAutoTarget();});
    E.outlookGrid.appendChild(label); E.outlookGrid.appendChild(btn);
  });
}
function syncControls(){
  E.rngTau.value=cfg.paretoTau; E.labTau.textContent=cfg.paretoTau.toFixed(2); E.statT.textContent=cfg.paretoTau.toFixed(2);
  E.chkAutoPareto.checked=cfg.autoPareto; E.rngTargetMass.value=cfg.targetMass; E.labTargetMass.textContent=cfg.targetMass.toFixed(2);
  E.rngNu.value=cfg.artNu; E.labNu.textContent=cfg.artNu;
  E.rngPts.value=cfg.artPoints; E.labPts.textContent=cfg.artPoints;
  E.rngMood.value=cfg.moodStrength; E.labMood.textContent=cfg.moodStrength.toFixed(2);
  E.rngLensR.value=lens.ang; E.labLensR.textContent=`${lens.ang}°`;
  E.rngBearing.value=intent.bearing=cfg.intBearing; E.labBearing.textContent=`${Math.round(intent.bearing)}°`;
  E.rngAlt.value=intent.alt=cfg.intAlt; E.labAlt.textContent=`${Math.round(intent.alt)}°`;
  E.rngMag.value=intent.mag=cfg.intMag; E.labMag.textContent=intent.mag.toFixed(2);
  E.rngGain.value=intent.gain=cfg.intGain; E.labGain.textContent=intent.gain.toFixed(2);
  globe.lon0=cfg.obsLon; globe.lat0=cfg.obsLat; E.rngObsLon.value=globe.lon0; E.labObsLon.textContent=`${Math.round(globe.lon0)}°`; E.rngObsLat.value=globe.lat0; E.labObsLat.textContent=`${Math.round(globe.lat0)}°`;
  E.chkAutoExec.checked=(cfg.execMode==='auto');
  E.rngAutoSpeed.value=auto.speed; E.labAutoSpeed.textContent=auto.speed.toFixed(2);
}

/* ===== Field generation & weights ===== */
function recomputeWeights(){weights=softmax(points.map(p=>p.sal),Math.max(0.05,cfg.paretoTau));}
function buildART(){
  const r=rng(seed); points=[]; let pos=0,neg=0;
  const centerAz=lens.az, centerAlt=lens.alt; const scaleAz=40, scaleAlt=25;
  const V=skyVec(intent.bearing, intent.alt);
  for(let i=0;i<cfg.artPoints;i++){
    const dim=DIMENSIONS[i%DIMENSIONS.length];
    const daz=studentT(cfg.artNu,r)*scaleAz, dalt=studentT(cfg.artNu,r)*scaleAlt;
    let az=(centerAz+daz+360)%360, alt=Math.max(0,Math.min(90,centerAlt+dalt));
    const P=skyVec(az,alt);
    const align = Math.max(0, dot(V,P));
    const angDist = Math.acos(Math.max(-1, Math.min(1, dot(skyVec(centerAz,centerAlt), P) )));
    const base=1/(1+(angDist/(Math.PI/4))**2);
    const mood=outlook[dim]||+1;
    const moodGain=1+cfg.moodStrength*(mood*0.25);
    const sal=base * (1 + intent.mag * intent.gain * align) * moodGain;
    points.push({lon:az,lat:alt,sal,dim,mood});
    if(mood>=0) pos++; else neg++;
  }
  const maxS=points.reduce((m,p)=>Math.max(m,p.sal),1e-6); for(const p of points){p.sal/=maxS;}
  recomputeWeights();
  lockSet.clear();
  if(cfg.lockTopK>0){ const top=[...points.map((p,i)=>[p.sal,i])].sort((a,b)=>b[0]-a[0]).slice(0,Math.max(3,Math.floor(points.length*0.02))).map(x=>x[1]); for(const i of top) lockSet.add(i); }
  E.statPos.textContent=pos; E.statNeg.textContent=neg;
}
function ensurePoints(){ if(!points || !Array.isArray(points) || points.length===0){ buildART(); } }

/* ===== Gauges & lens scoring ===== */
function computeDS2Dual(activeIdx){
  if(points.length===0) return {g:0,v:0};
  function posOf(p){ const P=projSky(p.lon, p.lat); return {x:P.x,y:P.y,vis:P.visible}; }
  let idx=activeIdx.length?activeIdx:[...points.map((p,i)=>[p.sal,i])].sort((a,b)=>b[0]-a[0]).slice(0,Math.max(3,Math.floor(points.length*0.05))).map(x=>x[1]);
  const Q=cfg.qualityQ||1, K=(a,b)=>{const dx=a.x-b.x,dy=a.y-b.y,d2=dx*dx+dy*dy;return Math.exp(-d2/3000);}, G=(a,b)=>1/(Math.hypot(a.x-b.x,a.y-b.y)+1e-3);
  let dsg=0,dsv=0; for(const i of idx){const pi=posOf(points[i]); if(!pi.vis) continue; for(let j=0;j<points.length;j++){const pj=posOf(points[j]); if(!pj.vis) continue; const wi=weights[i]/Q, wj=weights[j]/Q; dsg+=wi*wj*K(pi,pj); dsv+=wi*wj*G(pi,pj);} }
  const squash=v=>1-Math.exp(-v/50); return {g:squash(dsg), v:squash(dsv)};
}
function lensScores(){
  const kernel=(lens.mode==='infosophic')?(a)=>Math.exp(-(a*a)/25):(a)=>1/(a+1e-2);
  let scores=new Float32Array(points.length), sum=0;
  for(let i=0;i<points.length;i++){
    const P=projSky(points[i].lon,points[i].lat); if(P.visible===false){scores[i]=0; continue;}
    const ang= Math.acos( Math.max(-1, Math.min(1, dot(skyVec(lens.az,lens.alt), skyVec(points[i].lon, points[i].lat)) )) );
    const angDeg = toDeg(ang);
    if(angDeg>lens.ang){scores[i]=0;continue;}
    const s=(weights[i]/Math.max(0.5,cfg.qualityQ))*kernel(angDeg);
    scores[i]=s; sum+=s;
  }
  const m=Math.max(1e-6,...scores); for(let i=0;i<scores.length;i++) scores[i]/=m; const dsLocal=1-Math.exp(-sum/20); return {scores, dsLocal};
}

/* ===== Dynamic Pareto ===== */
function headStatsForTarget(target){const arr=weights.slice().sort((a,b)=>b-a); let cum=0,k=0; for(k=0;k<arr.length;k++){cum+=arr[k]; if(cum>=target) break;} return {k:k+1,headFrac:(k+1)/arr.length,mass:Math.min(1,cum)};}
function autoAdjustTau(dt){const {headFrac}=headStatsForTarget(cfg.targetMass); const err=headFrac-0.20; const step=-1.0*err*dt; cfg.paretoTau=Math.min(1.5,Math.max(0.05,cfg.paretoTau+step)); E.rngTau.value=cfg.paretoTau; E.labTau.textContent=cfg.paretoTau.toFixed(2); E.statT.textContent=cfg.paretoTau.toFixed(2); recomputeWeights();}

/* ===== Drawing (sky) ===== */
function drawParetoBar(){ if(weights.length===0) return; const x=12,y=12,W=320,H=50; ctx.save(); ctx.fillStyle='rgba(16,20,30,.78)'; ctx.strokeStyle='#27304a'; ctx.lineWidth=1; ctx.beginPath(); ctx.roundRect(x,y,W,H,10); ctx.fill(); ctx.stroke();
  const arr=weights.slice().sort((a,b)=>b-a); let cum=0,kStar=arr.length; for(let i=0;i<arr.length;i++){cum+=arr[i]; if(cum>=cfg.targetMass){kStar=i+1; break;}} const headFrac=kStar/arr.length, headW=Math.floor(W*headFrac);
  ctx.fillStyle='rgba(110,231,166,.35)'; ctx.fillRect(x+1,y+H-16,headW-2,10); ctx.fillStyle='rgba(97,218,251,.25)'; ctx.fillRect(x+headW,y+H-16,W-headW-1,10);
  ctx.fillStyle='#cfe8ff'; ctx.font='12px ui-monospace'; ctx.fillText(`Pareto — τ=${cfg.paretoTau.toFixed(2)} • head ${kStar}/${arr.length} (${(headFrac*100).toFixed(1)}%) • mass ${Math.min(cum,1).toFixed(2)}`, x+8, y+18);
  E.statK.textContent=`${kStar}/${arr.length}`; E.statMass.textContent=Math.min(cum,1).toFixed(2); ctx.restore(); }

function drawSky(){
  const {cx,cy,R}=projBase();
  const g=ctx.createRadialGradient(cx,cy,0,cx,cy,R*0.95); g.addColorStop(0,'#0b1222'); g.addColorStop(1,'#05080f'); ctx.fillStyle=g; ctx.fillRect(0,0,stage.clientWidth,stage.clientHeight);
  ctx.beginPath(); ctx.arc(cx,cy,R*0.9,0,Math.PI*2); ctx.strokeStyle='rgba(180,200,255,.15)'; ctx.lineWidth=2; ctx.stroke();
  ctx.strokeStyle='rgba(200,220,255,.08)'; ctx.lineWidth=1; for(let alt=10; alt<=80; alt+=10){ const P=projSky(0,alt); ctx.beginPath(); ctx.arc(P.cx,P.cy,P.rho,0,Math.PI*2); ctx.stroke(); }
  for(let az=0; az<360; az+=30){ const P0=projSky(az,0.1), P1=projSky(az,85); ctx.beginPath(); ctx.moveTo(P0.x,P0.y); ctx.lineTo(P1.x,P1.y); ctx.stroke(); }

  // intent vector glyph
  const vStart=projSky(lens.az,lens.alt); const vEnd=projSky(intent.bearing, Math.min(90, Math.max(0,intent.alt)));
  ctx.save(); ctx.strokeStyle='rgba(121,255,225,.85)'; ctx.lineWidth=2.5; ctx.setLineDash([8,6]); ctx.beginPath(); ctx.moveTo(vStart.x,vStart.y); ctx.lineTo(vEnd.x,vEnd.y); ctx.stroke(); ctx.setLineDash([]);
  ctx.fillStyle='rgba(121,255,225,.9)'; ctx.beginPath(); ctx.arc(vEnd.x,vEnd.y,5+3*intent.mag,0,Math.PI*2); ctx.fill();
  ctx.font='12px ui-monospace'; const lbl=`Intent → az ${Math.round(intent.bearing)}°, alt ${Math.round(intent.alt)}°, m=${intent.mag.toFixed(2)}, g=${intent.gain.toFixed(2)}`;
  const tw=ctx.measureText(lbl).width+10; ctx.fillStyle='rgba(16,20,30,.85)'; ctx.strokeStyle='#27304a'; ctx.lineWidth=1; ctx.beginPath(); ctx.roundRect(vEnd.x-tw/2, vEnd.y+10, tw, 20, 6); ctx.fill(); ctx.stroke(); ctx.fillStyle='#cfe8ff'; ctx.fillText(lbl, vEnd.x-tw/2+6, vEnd.y+25);
  ctx.restore();

  const ds=computeDS2Dual([...lockSet]); ctx.strokeStyle='rgba(159,122,234,.85)'; ctx.lineWidth=2; ctx.beginPath(); ctx.ellipse(cx,cy,R*0.28*(.6+.6*ds.g),R*0.28*(.6+.6*ds.v),0,0,Math.PI*2); ctx.stroke();
  renderPoints(); drawLensSky();
  E.statG.textContent=ds.g.toFixed(3); E.statV.textContent=ds.v.toFixed(3);
}
function lensPathSky(){
  const steps=180,alpha=lens.ang; ctx.beginPath();
  for(let i=0;i<=steps;i++){
    const t=2*Math.PI*i/steps; const col0=90-lens.alt, az0=lens.az;
    const col=Math.acos(Math.cos(toRad(alpha))*Math.cos(toRad(col0))+Math.sin(toRad(alpha))*Math.sin(toRad(col0))*Math.cos(t));
    const dAz=Math.atan2(Math.sin(t)*Math.sin(toRad(alpha))*Math.sin(toRad(col0)),Math.cos(toRad(alpha))-Math.cos(toRad(col))*Math.cos(toRad(col0)));
    const az=(az0+toDeg(dAz)+360)%360, alt=90-toDeg(col); const P=projSky(az,alt);
    if(i===0) ctx.moveTo(P.x,P.y); else ctx.lineTo(P.x,P.y);
  }
}
function drawLensSky(){
  const {scores,dsLocal}=lensScores(); const {cx,cy,R}=projBase();
  ctx.save(); ctx.beginPath(); ctx.arc(cx,cy,R*0.9,0,Math.PI*2); ctx.clip();
  ctx.save(); ctx.beginPath(); lensPathSky(); ctx.clip();
  for(let i=0;i<points.length;i++){
    const sAltAz={az:points[i].lon, alt:points[i].lat}; if(sAltAz.alt<0) continue;
    const P=projSky(sAltAz.az,sAltAz.alt); const val=scores[i]; if(val<=0) continue;
    const a=.25+.55*val; const col=(lens.mode==='infosophic')?`hsla(195,90%,60%,${a})`:`hsla(40,95%,60%,${a})`;
    ctx.beginPath(); ctx.fillStyle=col; ctx.arc(P.x,P.y,1.5+3*val,0,Math.PI*2); ctx.fill();
  }
  ctx.restore();
  ctx.lineWidth=2.2; ctx.setLineDash([6,4]); ctx.strokeStyle=(lens.mode==='infosophic')?'rgba(97,218,251,.9)':'rgba(251,191,36,.9)';
  ctx.beginPath(); lensPathSky(); ctx.stroke(); ctx.setLineDash([]);
  const Pc=projSky(lens.az,lens.alt);
  const label=(lens.mode==='infosophic')?'Infosophic sextant (∇⁻¹)':'Simulonic sextant (∇¹)⁻¹';
  const text=`${label} • r=${lens.ang}° • local ds²=${dsLocal.toFixed(3)}`;
  ctx.fillStyle='rgba(16,20,30,.85)'; ctx.strokeStyle='#27304a'; ctx.lineWidth=1; ctx.font='12px ui-monospace';
  const w=ctx.measureText(text).width+12,h=20; ctx.beginPath(); ctx.roundRect(Pc.x-w/2,Pc.y-30,w,h,6); ctx.fill(); ctx.stroke(); ctx.fillStyle='#cfe8ff'; ctx.fillText(text,Pc.x-w/2+6,Pc.y-16);
}
function renderPoints(){
  let posCount=0,negCount=0;
  for(let i=0;i<points.length;i++){
    const P=projSky(points[i].lon,points[i].lat); if(!P.visible) continue;
    const w=weights[i]||0; const rPt=1.2+3.8*w; const locked=lockSet.has(i);
    const dimIdx=DIMENSIONS.indexOf(points[i].dim); const baseHue=(dimIdx*37)%360; const hue=(points[i].mood>=0)?(baseHue*0.7+120*0.3):(baseHue*0.7+0*0.3); const alpha=0.55+0.35*w;
    ctx.beginPath(); ctx.fillStyle=locked?`hsl(160 90% 60% / .95)`: `hsl(${hue} 80% 60% / ${alpha})`; ctx.strokeStyle=locked?'rgba(110,231,166,.85)':(points[i].mood>=0?'rgba(110,231,166,.28)':'rgba(248,113,113,.28)'); ctx.lineWidth=locked?1.4:0.8;
    ctx.arc(P.x,P.y,rPt*(locked?1.25:1.0),0,Math.PI*2); ctx.fill(); ctx.stroke();
    if(locked){ctx.beginPath(); ctx.setLineDash([3,3]); ctx.strokeStyle='rgba(110,231,166,.25)'; ctx.arc(P.x,P.y,rPt*2.0,0,Math.PI*2); ctx.stroke(); ctx.setLineDash([]);} 
    if(points[i].mood>=0) posCount++; else negCount++;
  }
  E.statPos.textContent=posCount; E.statNeg.textContent=negCount;
}

/* ===== Auto-sextant targeting ===== */
function vecToAzAlt(v){ const alt=Math.asin(Math.max(-1,Math.min(1,v.z))); const az=(Math.atan2(v.x,v.y)+2*Math.PI)%(2*Math.PI); return {az:toDeg(az), alt:toDeg(alt)}; }
function computeSkyAutoTarget(){
  let vx=0,vy=0,vz=0, wsum=0;
  const add = (az,alt,w)=>{ const v=skyVec(az,alt); vx+=v.x*w; vy+=v.y*w; vz+=v.z*w; wsum+=w; };
  const consider = (i,wExtra=0)=>{ const w=(weights[i]||0)+wExtra; if(w<=0) return; add(points[i].lon, points[i].lat, w); };
  if(lockSet.size>0){ for(const i of lockSet) consider(i,0.6); }
  else { const idx=[...points.map((p,i)=>[weights[i],i])].sort((a,b)=>b[0]-a[0]).slice(0,Math.max(20,Math.floor(points.length*0.05))).map(x=>x[1]); for(const i of idx) consider(i,0); }
  if(wsum<=0){ auto.targetAz=null; auto.targetAlt=null; return; }
  const vnorm=Math.hypot(vx,vy,vz)||1; const v={x:vx/vnorm,y:vy/vnorm,z:vz/vnorm}; const tar=vecToAzAlt(v);
  auto.targetAz=tar.az; auto.targetAlt=Math.max(0, Math.min(90, tar.alt));
}
function stepLensTowardTarget(dt){
  if(!auto.enabled || auto.targetAz==null || auto.targetAlt==null) return;
  if(lens.dragging || globe.dragging || auto.cooldown>0){ auto.cooldown=Math.max(0, auto.cooldown-dt); return; }
  const speed = auto.speed;
  let dAz = ((auto.targetAz - lens.az + 540) % 360) - 180;
  lens.az = (lens.az + dAz*speed + 360) % 360;
  lens.alt += (auto.targetAlt - lens.alt) * speed;
  lens.alt = Math.max(0, Math.min(90, lens.alt));
}

/* ===== Runtime (minimal) ===== */
function contextSnapshot(){ const ds=computeDS2Dual([...lockSet]); const head=headStatsForTarget(cfg.targetMass);
  return {observer:{lon:globe.lon0,lat:globe.lat0}, lens:{kind:lens.mode,az:lens.az,alt:lens.alt,radiusDeg:lens.ang}, intent:{bearing:intent.bearing,alt:intent.alt,mag:intent.mag,gain:intent.gain},
    ds2:{green:+ds.g.toFixed(6),vacuum:+ds.v.toFixed(6)}, tau:+cfg.paretoTau.toFixed(6), head:{k:head.k,mass:+head.mass.toFixed(6)}, selected:{indices:[...lockSet],count:lockSet.size}, pointsCount:points.length, timestamp:new Date().toISOString()};}
function executeSimuLang(){ const {scores}=lensScores(); let sum=0,n=0; for(let i=0;i<scores.length;i++){ if(scores[i]>0){sum+=scores[i];n++;}} const lensIntensity=(n?sum/n:0);
  return {cfgUsed:{execMode:cfg.execMode,execMetric:'lens_intensity'}, result:{metric:'lens_intensity',value:+lensIntensity.toFixed(6)}};}
function appendLog(ctxObj,exec){ const line=document.createElement('div'); line.className='line'; const p1=document.createElement('div'); p1.innerHTML=`<span class="tag exec">EXEC</span> <span class="mono">${ctxObj.timestamp}</span>`; const pre=document.createElement('pre'); pre.textContent=JSON.stringify({context:ctxObj,...exec},null,2); E.runtimeLog.prepend(line); line.appendChild(p1); line.appendChild(pre); }
function maybeAutoExec(){ if(!E.chkAutoExec.checked) return; const c=contextSnapshot(); const ex=executeSimuLang(c); appendLog(c,ex); }

/* ===== Render loop ===== */
let lastT=performance.now();
function render(t){
  const dt=Math.min(0.1,(t-lastT)/1000); lastT=t;
  if(cfg.autoPareto && points.length>0) autoAdjustTau(dt);
  stepLensTowardTarget(dt);
  ctx.clearRect(0,0,stage.clientWidth,stage.clientHeight);
  ensurePoints();
  drawSky();
  drawParetoBar();
  E.statL.textContent=lockSet.size;
  requestAnimationFrame(render);
}

/* ===== Interaction (sky) ===== */
stage.addEventListener('mousedown', e=>{
  const r=stage.getBoundingClientRect(); const x=e.clientX-r.left, y=e.clientY-r.top;
  const inv=invSky(x,y); if(inv){ const ang= Math.acos( Math.max(-1, Math.min(1, dot(skyVec(inv.az,inv.alt), skyVec(lens.az, lens.alt)) )) ); if(toDeg(ang)<=lens.ang){ lens.dragging=true; } else { globe.dragging=true; globe.lastX=x; globe.lastY=y; } }
});
addEventListener('mouseup', ()=>{ const dragged=lens.dragging; globe.dragging=false; lens.dragging=false; if(dragged){ auto.cooldown=0.25; computeSkyAutoTarget(); maybeAutoExec(); } });
addEventListener('mousemove', e=>{
  const r=stage.getBoundingClientRect(); const x=e.clientX-r.left, y=e.clientY-r.top;
  if(globe.dragging){ const dx=x-globe.lastX, dy=y-globe.lastY; globe.lon0=((globe.lon0-dx*0.2+540)%360)-180; globe.lat0=Math.max(-80,Math.min(80,globe.lat0+dy*0.2)); globe.lastX=x; globe.lastY=y; }
  else if(lens.dragging){ const inv=invSky(x,y); if(inv){ lens.az=inv.az; lens.alt=Math.max(0,Math.min(90,inv.alt)); } }
});
stage.addEventListener('click', e=>{
  if(globe.dragging||lens.dragging) return;
  const r=stage.getBoundingClientRect(); const x=e.clientX-r.left,y=e.clientY-r.top; let best=-1,bd=1e9;
  for(let i=0;i<points.length;i++){
    const P=projSky(points[i].lon,points[i].lat); if(!P.visible) continue; const d=(P.x-x)*(P.x-x)+(P.y-y)*(P.y-y); if(d<bd){bd=d; best=i;}
  }
  if(best>=0){ if(lockSet.has(best)) lockSet.delete(best); else lockSet.add(best); computeSkyAutoTarget(); maybeAutoExec(); }
});

/* ===== Controls (sky) ===== */
E.rngObsLon.addEventListener('input', e=>{ globe.lon0=parseFloat(e.target.value); E.labObsLon.textContent=`${Math.round(globe.lon0)}°`; buildART(); ensurePoints(); computeSkyAutoTarget(); });
E.rngObsLat.addEventListener('input', e=>{ globe.lat0=parseFloat(e.target.value); E.labObsLat.textContent=`${Math.round(globe.lat0)}°`; buildART(); ensurePoints(); computeSkyAutoTarget(); });

E.rngTau.addEventListener('input', e=>{ cfg.paretoTau=parseFloat(e.target.value); E.labTau.textContent=cfg.paretoTau.toFixed(2); E.statT.textContent=cfg.paretoTau.toFixed(2); recomputeWeights(); computeSkyAutoTarget(); });
E.chkAutoPareto.addEventListener('change', e=>{ cfg.autoPareto=e.target.checked; });
E.rngTargetMass.addEventListener('input', e=>{ cfg.targetMass=parseFloat(e.target.value); E.labTargetMass.textContent=cfg.targetMass.toFixed(2); computeSkyAutoTarget(); });
E.rngNu.addEventListener('input', e=>{ cfg.artNu=parseInt(e.target.value,10); E.labNu.textContent=cfg.artNu; buildART(); ensurePoints(); computeSkyAutoTarget(); });
E.rngPts.addEventListener('input', e=>{ cfg.artPoints=parseInt(e.target.value,10); E.labPts.textContent=cfg.artPoints; buildART(); ensurePoints(); computeSkyAutoTarget(); });
E.rngMood.addEventListener('input', e=>{ cfg.moodStrength=parseFloat(e.target.value); E.labMood.textContent=cfg.moodStrength.toFixed(2); buildART(); ensurePoints(); computeSkyAutoTarget(); });
E.btnShuffle.addEventListener('click', ()=>{ seed=(seed*1664525+1013904223)>>>0; buildART(); ensurePoints(); computeSkyAutoTarget(); maybeAutoExec(); });
E.btnClear.addEventListener('click', ()=>{ lockSet.clear(); computeSkyAutoTarget(); maybeAutoExec(); });
E.btnLensMode.addEventListener('click', ()=>{ lens.mode = lens.mode==='infosophic' ? 'simulonic' : 'infosophic'; E.btnLensMode.textContent = (lens.mode==='infosophic' ? 'Lens: Infosophic (I)' : 'Lens: Simulonic (S)'); maybeAutoExec(); });
addEventListener('keydown', (e)=>{ if(e.key.toLowerCase()==='i'){ lens.mode='infosophic'; E.btnLensMode.textContent='Lens: Infosophic (I)'; maybeAutoExec(); }
                                   if(e.key.toLowerCase()==='s'){ lens.mode='simulonic'; E.btnLensMode.textContent='Lens: Simulonic (S)'; maybeAutoExec(); }});
E.rngLensR.addEventListener('input', e=>{ lens.ang=parseInt(e.target.value,10); E.labLensR.textContent=`${lens.ang}°`; buildART(); ensurePoints(); computeSkyAutoTarget(); });
E.chkAutoSextant.addEventListener('change', e=>{ auto.enabled=e.target.checked; if(auto.enabled){ computeSkyAutoTarget(); } });
E.rngAutoSpeed.addEventListener('input', e=>{ auto.speed=parseFloat(e.target.value); E.labAutoSpeed.textContent=auto.speed.toFixed(2); });

E.rngBearing.addEventListener('input', e=>{ intent.bearing=parseFloat(e.target.value); E.labBearing.textContent=`${Math.round(intent.bearing)}°`; buildART(); ensurePoints(); computeSkyAutoTarget(); });
E.rngAlt.addEventListener('input', e=>{ intent.alt=parseFloat(e.target.value); E.labAlt.textContent=`${Math.round(intent.alt)}°`; buildART(); ensurePoints(); computeSkyAutoTarget(); });
E.rngMag.addEventListener('input', e=>{ intent.mag=parseFloat(e.target.value); E.labMag.textContent=intent.mag.toFixed(2); buildART(); ensurePoints(); computeSkyAutoTarget(); });
E.rngGain.addEventListener('input', e=>{ intent.gain=parseFloat(e.target.value); E.labGain.textContent=intent.gain.toFixed(2); buildART(); ensurePoints(); computeSkyAutoTarget(); });

E.btnApply.addEventListener('click', ()=>{ const p=parseSimuLang(E.simTxt.value); cfg={...cfg, ...p}; intent.bearing=p.intBearing; intent.alt=p.intAlt; intent.mag=p.intMag; intent.gain=p.intGain; syncControls(); buildART(); ensurePoints(); computeSkyAutoTarget(); maybeAutoExec(); });
E.btnReset.addEventListener('click', ()=>{ E.simTxt.value=defaultSimuLang(); cfg=parseSimuLang(E.simTxt.value); intent.bearing=cfg.intBearing; intent.alt=cfg.intAlt; intent.mag=cfg.intMag; intent.gain=cfg.intGain; syncControls(); buildART(); ensurePoints(); computeSkyAutoTarget(); maybeAutoExec(); });
E.btnRun.addEventListener('click', ()=>{ const c=contextSnapshot(); const ex=executeSimuLang(c); appendLog(c,ex); });

/* ===== Init (Celestial) ===== */
function initCelestial(){
  fitCanvas();
  E.simTxt.value=defaultSimuLang();
  cfg=parseSimuLang(E.simTxt.value);
  syncControls();
  buildOutlookGrid();
  buildART();
  ensurePoints();
  computeSkyAutoTarget();
  requestAnimationFrame(render);
}
initCelestial();

/* ===== WarpDock: stage in shadow, controls in bottom-right panel ===== */
(function mountWarpDock(){
  const mount = $('warpMount');
  const root = mount.attachShadow({mode:'open'});
  root.innerHTML = `
    <style>
      :host{display:block}
      .stage{position:relative;min-height:520px;overflow:hidden;
        background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
        border:1px solid rgba(255,255,255,.08); border-radius:16px;
        box-shadow:0 10px 30px rgba(0,0,0,.45), inset 0 0 40px rgba(255,255,255,.03);
      }
      svg{width:100%;height:100%;display:block}
      .edge{ stroke:#6aa8ff; stroke-opacity:.38; stroke-width:5; fill:none; filter:url(#edgeGlow) }
      .edge.active{ stroke-opacity:.85; stroke-width:8 }
      .edge.main{ stroke-width:10; stroke-opacity:.95 }
      .node{ fill:#ffffff; stroke:#94c6ff; stroke-width:3; filter:url(#nodeGlow) }
      .hit{ fill:transparent; pointer-events:all }
      .label{ font-weight:800; font-size:14px; fill:#e8f0ff; paint-order:stroke; stroke:rgba(0,0,0,.55); stroke-width:3px; pointer-events:none }
      .sublabel{ font-size:12px; fill:#a5b1cc; pointer-events:none }
      .particle{ fill:#79ffe1; stroke:#cffff0; stroke-width:.6 }
      .warping{ animation: warpBlink .6s ease-in-out 1 }
      @keyframes warpBlink{0%{opacity:1;transform:scale(1)}35%{opacity:0;transform:scale(.25)}65%{opacity:0;transform:scale(.25)}100%{opacity:1;transform:scale(1)}}
      .intent-stem{ stroke:url(#fluxGrad); stroke-width:8; stroke-opacity:.85; fill:none }
      .intent-head{ fill:url(#fluxGrad); opacity:.9 }
      .intent-core{ fill:none; stroke:#79ffe1; stroke-dasharray:5 6; stroke-opacity:.5 }
    </style>

    <div class="stage">
      <svg id="graph" viewBox="0 0 1000 680" role="img" aria-labelledby="svgTitle svgDesc">
        <title id="svgTitle">Warp Drive Interaction Graph</title>
        <desc id="svgDesc">Core triangle + SFG ring; particle flows; CII intent bias.</desc>
        <defs>
          <filter id="edgeGlow" x="-50%" y="-50%" width="200%" height="200%">
            <feDropShadow dx="0" dy="0" stdDeviation="4" flood-color="#6aa8ff" flood-opacity=".55"/>
            <feDropShadow dx="0" dy="0" stdDeviation="10" flood-color="#79ffe1" flood-opacity=".28"/>
          </filter>
          <filter id="nodeGlow" x="-50%" y="-50%" width="200%" height="200%">
            <feDropShadow dx="0" dy="0" stdDeviation="4" flood-color="#ffffff" flood-opacity=".9"/>
            <feDropShadow dx="0" dy="0" stdDeviation="10" flood-color="#79ffe1" flood-opacity=".4"/>
          </filter>
          <linearGradient id="fluxGrad" x1="0%" y1="0%" x2="100%">
            <stop offset="0%" stop-color="#6aa8ff"/><stop offset="100%" stop-color="#79ffe1"/>
          </linearGradient>
          <marker id="arrowHead" viewBox="0 0 16 16" refX="8" refY="8" markerWidth="12" markerHeight="12" orient="auto-start-reverse">
            <path d="M0,0 L16,8 L0,16 L4,8 Z" class="intent-head"/>
          </marker>
        </defs>
        <g id="edges"></g>
        <g id="particles"></g>
        <g id="nodes"></g>
        <g id="intentLayer"></g>
      </svg>
    </div>
  `;

  // ==== Scoped WarpDock logic ====
  const NS = 'http://www.w3.org/2000/svg';
  const svg = root.getElementById('graph');
  const edgeLayer = root.getElementById('edges');
  const particleLayer = root.getElementById('particles');
  const nodeLayer = root.getElementById('nodes');
  const intentLayer = root.getElementById('intentLayer');

  // Nodes
  const CORE = [
    { id:'INC', label:'Inertial Null Core', sub:'Nullness • Stability', r:28, x:170, y:340 },
    { id:'MEA', label:'Membrane Emitter Array', sub:'Gain • Density', r:26, x:430, y:130 },
    { id:'HO',  label:'Harmonic Oscillator', sub:'Frequency • Q', r:26, x:770, y:340 },
  ];
  const CENTER = { x:500, y:340, R:150 };
  const SFGS = Array.from({length:12}, (_,i) => {
    const a = (i/12)*Math.PI*2;
    return { id:`SFG${i+1}`, label:'SFG', sub:`Simulonic Field Gen #${i+1}`, r:18,
             x: CENTER.x + CENTER.R*Math.cos(a),
             y: CENTER.y + CENTER.R*Math.sin(a) };
  });
  const ALL = [...CORE, ...SFGS];

  function makeNode(n){
    const g = document.createElementNS(NS,'g');
    g.classList.add('node-wrap'); g.dataset.id=n.id;
    g.setAttribute('transform', `translate(${n.x},${n.y})`);
    const hit = document.createElementNS(NS,'circle'); hit.setAttribute('class','hit'); hit.setAttribute('r', n.r+20);
    const c   = document.createElementNS(NS,'circle'); c.setAttribute('class','node'); c.setAttribute('r', n.r);
    const t1  = document.createElementNS(NS,'text');  t1.setAttribute('class','label'); t1.setAttribute('text-anchor','middle'); t1.setAttribute('dy', -(n.r+20)); t1.textContent = n.label;
    const t2  = document.createElementNS(NS,'text');  t2.setAttribute('class','sublabel'); t2.setAttribute('text-anchor','middle'); t2.setAttribute('dy', n.r+22); t2.textContent = n.sub;
    g.appendChild(hit); g.appendChild(c); g.appendChild(t1); g.appendChild(t2);
    nodeLayer.appendChild(g);
    n.g=g; n.hit=hit; n.circ=c;
  }
  ALL.forEach(makeNode);

  // Drag core nodes
  CORE.forEach(n=>{
    let dragging=false, ox=0, oy=0;
    n.hit.addEventListener('pointerdown', e=>{ dragging=true; e.target.setPointerCapture(e.pointerId); ox=e.clientX-n.x; oy=e.clientY-n.y; });
    root.host.ownerDocument.defaultView.addEventListener('pointermove', e=>{
      if(!dragging) return;
      n.x = Math.max(40, Math.min(960, e.clientX - ox));
      n.y = Math.max(60, Math.min(640, e.clientY - oy));
      n.g.setAttribute('transform', `translate(${n.x},${n.y})`);
      updateAllEdges(); updateIntentGraphics();
    });
    root.host.ownerDocument.defaultView.addEventListener('pointerup', ()=> dragging=false);
  });

  // Edges
  const edges=[];
  function bez(a,b,bulge=24){
    const dx=b.x-a.x, dy=b.y-a.y, mx=(a.x+b.x)/2, my=(a.y+b.y)/2;
    const len=Math.hypot(dx,dy)||1, ux=-dy/len, uy=dx/len;
    const cx = mx + ux*bulge, cy = my + uy*bulge;
    return `M ${a.x} ${a.y} Q ${cx} ${cy} ${b.x} ${b.y}`;
  }
  function addEdge(a,b, main=false){
    const p = document.createElementNS(NS,'path');
    p.setAttribute('class','edge' + (main?' main':'')); p.setAttribute('stroke','url(#fluxGrad)');
    p.setAttribute('d', bez(a,b, main?40:24));
    edgeLayer.appendChild(p);
    edges.push({a,b,path:p,main});
  }
  addEdge(ALL.find(n=>n.id==='INC'), ALL.find(n=>n.id==='MEA'), true);
  addEdge(ALL.find(n=>n.id==='MEA'), ALL.find(n=>n.id==='HO'),  true);
  addEdge(ALL.find(n=>n.id==='HO'),  ALL.find(n=>n.id==='INC'), true);
  for(let i=0;i<ALL.length;i++){
    for(let j=i+1;j<ALL.length;j++){
      const ia=ALL[i].id, jb=ALL[j].id;
      const isMain = (ia==='INC'&&jb==='MEA')||(ia==='MEA'&&jb==='HO')||(ia==='HO'&&jb==='INC');
      if(!isMain) addEdge(ALL[i], ALL[j], false);
    }
  }
  function updateAllEdges(){ edges.forEach(e=> e.path.setAttribute('d', bez(e.a,e.b, e.main?40:24))); }

  // Particles
  const MAX_PARTICLES = 900;
  const particles=[];
  function spawnParticleOnPath(path, intensity=1){
    if(particles.length >= MAX_PARTICLES){
      const old = particles.shift();
      if(old?.el?.parentNode) old.el.parentNode.removeChild(old.el);
    }
    const el = document.createElementNS(NS,'circle');
    el.setAttribute('class','particle');
    const baseR = 2.8;
    el.setAttribute('r', (baseR + Math.random()*1.4*intensity).toFixed(2));
    particleLayer.appendChild(el);
    const p = { el, path, t: Math.random()*0.2, speed: 0.0022 + Math.random()*0.003*intensity };
    particles.push(p);
    try {
      const len = path.getTotalLength();
      const pt  = path.getPointAtLength(p.t * len);
      el.setAttribute('cx', pt.x); el.setAttribute('cy', pt.y);
      el.setAttribute('opacity', 0.55 + 0.4*(1-p.t));
    } catch(e){}
  }
  function connectedEdgesOf(node){ return edges.filter(e=> e.a===node || e.b===node); }
  function burstFromNode(node, magnitude=1){
    const connected = connectedEdgesOf(node);
    connected.forEach(e=> e.path.classList.add('active'));
    setTimeout(()=> connected.forEach(e=> e.path.classList.remove('active')), 900);
    const count = Math.floor(8 + 16*magnitude);
    for(const e of connected){
      for(let i=0;i<count;i++) spawnParticleOnPath(e.path, 0.9 + 0.6*magnitude);
    }
  }

  // Intent vector graphics
  function deg2rad(d){ return d*Math.PI/180; }
  const intentStem = document.createElementNS(NS,'path');
  intentStem.setAttribute('class','intent-stem'); intentStem.setAttribute('marker-end','url(#arrowHead)');
  const intentCore = document.createElementNS(NS,'circle');
  intentCore.setAttribute('class','intent-core'); intentCore.setAttribute('cx', CENTER.x); intentCore.setAttribute('cy', CENTER.y); intentCore.setAttribute('r', CENTER.R+18);
  const intentLabel = document.createElementNS(NS,'text');
  intentLabel.setAttribute('x', CENTER.x); intentLabel.setAttribute('y', CENTER.y- (CENTER.R+36));
  intentLabel.setAttribute('text-anchor','middle'); intentLabel.setAttribute('class','label'); intentLabel.textContent='CII Intent';
  intentLayer.appendChild(intentCore); intentLayer.appendChild(intentStem); intentLayer.appendChild(intentLabel);

  // Internal (shadow) state derived from outside controls
  const Outside = {
    bias: 0.50,
    flux: 0.80,
    bearing: 0,
    mag: 0.70,
    gain: 0.60,
    focus: 'all',
    target: 'INC',
    autoSteer: false
  };

  function intentVec(){
    const th = deg2rad(Outside.bearing);
    const m = Outside.mag;
    return { x: Math.cos(th)*m, y: Math.sin(th)*m, th, m };
  }
  function updateIntentGraphics(){
    const R = CENTER.R + 130;
    const V = intentVec();
    const x2 = CENTER.x + Math.cos(V.th)*R;
    aconst = 0; // keep scope clean in template string
    const y2 = CENTER.y + Math.sin(V.th)*R;
    const scale = 0.35 + 0.65*V.m;
    const xEnd = CENTER.x + (x2-CENTER.x)*scale;
    const yEnd = CENTER.y + (y2-CENTER.y)*scale;
    const ctrl = 0.18;
    const cx = CENTER.x + (xEnd-CENTER.x)* (1-ctrl) - (yEnd-CENTER.y)*0.08;
    const cy = CENTER.y + (yEnd-CENTER.y)* (1-ctrl) + (xEnd-CENTER.x)*0.08;
    intentStem.setAttribute('d', `M ${CENTER.x} ${CENTER.y} Q ${cx} ${cy} ${xEnd} ${yEnd}`);
  }
  updateIntentGraphics();

  function isCore(n){ return n.id==='INC'||n.id==='MEA'||n.id==='HO'; }
  function isSFG(n){ return n.id.startsWith('SFG'); }
  function nodeById(id){ return ALL.find(n=>n.id===id); }

  function pickIntentWeightedEdge(){
    const V = intentVec();
    const g = Outside.gain;
    const focus = Outside.focus;
    const target = nodeById(Outside.target);
    let total = 0;
    const wts = new Array(edges.length).fill(0);
    for(let i=0;i<edges.length;i++){
      const e = edges[i];
      if(focus==='core' && !(isCore(e.a) && isCore(e.b))) { wts[i]=0; continue; }
      if(focus==='sfg' && !(isSFG(e.a) && isSFG(e.b))) { wts[i]=0; continue; }
      if(focus==='target' && !(e.a===target || e.b===target)) { wts[i]=0; continue; }
      const mx=(e.a.x+e.b.x)/2, my=(e.a.y+e.b.y)/2;
      const ex = mx - CENTER.x, ey = my - CENTER.y;
      const L = Math.hypot(ex,ey)||1; const dx = ex/L, dy = ey/L;
      const align = Math.max(0, (dx*V.x + dy*V.y));
      const base = 1;
      const w = base * (1 + V.m * g * align);
      wts[i]=w; total += w;
    }
    if(total<=0) return edges[(Math.random()*edges.length)|0];
    let r = Math.random()*total;
    for(let i=0;i<wts.length;i++){ r -= wts[i]; if(r<=0) return edges[i]; }
    return edges[edges.length-1];
  }

  function continuousEmit(){
    const f = Outside.flux;
    const emitEdges = Math.floor(2 + f * 14);
    for(let i=0;i<emitEdges;i++){
      const e = pickIntentWeightedEdge();
      const intensity = 0.6 + 0.9*f;
      spawnParticleOnPath(e.path, intensity);
    }
  }

  // Clicks: bursts & warp threshold
  const warpCounter = Object.fromEntries(ALL.map(n=>[n.id,0]));
  const WARP_THRESHOLD = 5;
  function doWarp(n){
    n.g.classList.add('warping');
    setTimeout(()=> n.g.classList.remove('warping'), 620);
    if(n.id.startsWith('SFG')){
      const j=6; n.x += (Math.random()*2-1)*j; n.y += (Math.random()*2-1)*j;
      n.g.setAttribute('transform', `translate(${n.x},${n.y})`);
      updateAllEdges(); updateIntentGraphics();
    }
  }
  ALL.forEach(n=>{
    n.hit.addEventListener('click', (evt)=>{
      burstFromNode(n, 1.2);
      warpCounter[n.id] += 1;
      if(warpCounter[n.id] >= WARP_THRESHOLD){ warpCounter[n.id]=0; doWarp(n); }
      if(evt.shiftKey){ Outside.target = n.id; updateIntentGraphics(); setUIFromOutside(); }
    });
  });

  // Metrics
  function computeRingSymmetry(){
    const targetR = CENTER.R; let acc = 0;
    for(const s of SFGS){
      const dr = Math.abs(Math.hypot(s.x-CENTER.x, s.y-CENTER.y)-targetR);
      acc += Math.max(0, 1 - Math.min(1, Math.abs(dr)/20));
    }
    return acc / SFGS.length;
  }
  function computeIntentAlignment(){
    const V = intentVec();
    let ax=0, ay=0;
    for(const s of SFGS){
      const vx = s.x - CENTER.x, vy = s.y - CENTER.y;
      const L = Math.hypot(vx,vy)||1;
      ax += vx/L; ay += vy/L;
    }
    const L = Math.hypot(ax,ay)||1; ax/=L; ay/=L;
    return Math.max(0, ax*V.x + ay*V.y);
  }
  function computeState(){
    const particleFactor = Math.min(1, particles.length / MAX_PARTICLES);
    const ringSymmetry   = computeRingSymmetry();
    const intentAlign    = computeIntentAlignment();
    const coupling = Math.max(0, Math.min(1, 0.26*particleFactor + 0.24*ringSymmetry + 0.35*(Outside.flux) + 0.15*intentAlign*(Outside.gain)/2 ));
    const coherence= Math.max(0, Math.min(1, 0.42*ringSymmetry + 0.18*particleFactor + 0.30*(1 - Math.abs(Outside.bias-0.5)*2) + 0.10*intentAlign ));
    let readiness='Idle', cls='warn';
    if(coupling>0.75 && coherence>0.75){ readiness='Warp-Ready'; cls='ok' }
    else if(coupling>0.5 && coherence>0.5){ readiness='Aligning'; cls='warn' }
    else { readiness='Unstable'; cls='bad' }
    return {coupling, coherence, readiness, cls};
  }

  // Auto-steer bearing toward worst ring deviation
  function autoSteerUpdate(dt){
    if(!Outside.autoSteer) return;
    let worst=null, worstErr=-1;
    const R = CENTER.R;
    for(const s of SFGS){
      const dr = Math.abs(Math.hypot(s.x-CENTER.x, s.y-CENTER.y)-R);
      if(dr>worstErr){ worstErr=dr; worst=s; }
    }
    if(!worst) return;
    const ang = Math.atan2(CENTER.y - worst.y, CENTER.x - worst.x);
    let current = (Outside.bearing*Math.PI/180);
    let diff = ((ang - current + Math.PI*3) % (Math.PI*2)) - Math.PI;
    const rate = 0.9;
    const step = Math.max(-rate*dt, Math.min(rate*dt, diff));
    current += step;
    let deg = current*180/Math.PI; if(deg<0) deg+=360;
    Outside.bearing = (deg % 360);
    updateIntentGraphics();
  }

  // Animation
  let running=true, last=performance.now()/1000;
  function tick(ms){
    const now=ms/1000, dt=Math.min(0.05, now-last); last=now;
    continuousEmit();
    for(let i=particles.length-1;i>=0;i--){
      const p=particles[i];
      const speedScale = 0.35 + 1.6*(Outside.flux);
      p.t += p.speed * speedScale * (1 + 0.25*Math.sin(now*2 + i));
      if(p.t>=1){ if(p.el?.parentNode) p.el.parentNode.removeChild(p.el); particles.splice(i,1); continue; }
      try{ const len=p.path.getTotalLength(); const pt=p.path.getPointAtLength(p.t*len); p.el.setAttribute('cx',pt.x); p.el.setAttribute('cy',pt.y); p.el.setAttribute('opacity',0.6+0.35*(1-p.t)); }catch(e){}
    }
    autoSteerUpdate(dt);
    const S = computeState();
    // push meters to outer UI
    if(window.__warpMeters){
      const {coupling, coherence, readiness, cls} = S;
      __warpMeters.coupling.textContent=coupling.toFixed(2);
      __warpMeters.coherence.textContent=coherence.toFixed(2);
      __warpMeters.readiness.textContent=readiness;
      __warpMeters.readiness.className='v ' + (cls==='ok'?'ok':cls==='warn'?'warn':'bad');
    }
    if(running) requestAnimationFrame(tick);
  }
  // Seed particles
  for(let i=0;i<200;i++){ const e = edges[(Math.random()*edges.length)|0]; spawnParticleOnPath(e.path, 0.9); }
  requestAnimationFrame(tick);

  // ---- Bridge to bottom controls (light DOM) ----
  window.__warpSet = function setWarpControls(next){
    Object.assign(Outside, next);
    updateIntentGraphics();
  };
  window.__warpBurstNode = function(id){
    const n = nodeById(id) || ALL[0];
    burstFromNode(n, 1.5);
  };
  window.__warpToggle = function(){
    running = !running;
    if(running){ last=performance.now()/1000; requestAnimationFrame(tick); }
    return running;
  };
  window.__warpReset = function(){
    Object.keys(warpCounter).forEach(k=> warpCounter[k]=0);
    SFGS.forEach((s,i)=>{ const a=(i/12)*Math.PI*2; s.x=CENTER.x + CENTER.R*Math.cos(a); s.y=CENTER.y + CENTER.R*Math.sin(a); s.g.setAttribute('transform',`translate(${s.x},${s.y})`); });
    updateAllEdges(); updateIntentGraphics();
  };

  // Local helper for shift-click targeting:
  function setUIFromOutside(){
    const tgt = document.getElementById('w_target'); if(tgt){ tgt.value = Outside.target; }
  }
})(); // end mountWarpDock

/* ===== Build Warp controls in bottom-right panel and wire to shadow ===== */
(function buildWarpControls(){
  const wrap = $('warpControls');
  wrap.innerHTML = `
    <div class="h">WarpDock Controls</div>
    <div class="row"><span class="muted">Resonance Bias</span><input id="w_bias" type="range" min="0" max="1" step="0.01" value="0.50" style="flex:1"><output class="mono" id="wo_bias">0.50</output></div>
    <div class="row"><span class="muted">Flux Intensity</span><input id="w_flux" type="range" min="0" max="1" step="0.01" value="0.80" style="flex:1"><output class="mono" id="wo_flux">0.80</output></div>
    <div class="row"><span class="muted">Bearing (°)</span><input id="w_bearing" type="range" min="0" max="360" step="1" value="0" style="flex:1"><output class="mono" id="wo_bearing">0</output></div>
    <div class="row"><span class="muted">Magnitude</span><input id="w_mag" type="range" min="0" max="1" step="0.01" value="0.70" style="flex:1"><output class="mono" id="wo_mag">0.70</output></div>
    <div class="row"><span class="muted">Gain</span><input id="w_gain" type="range" min="0" max="2" step="0.01" value="0.60" style="flex:1"><output class="mono" id="wo_gain">0.60</output></div>
    <div class="row">
      <span class="muted">Focus</span>
      <select id="w_focus" style="flex:1">
        <option value="all">All Links</option>
        <option value="core">Core Triangle</option>
        <option value="sfg">SFG Ring</option>
        <option value="target">Toward Target Node</option>
      </select>
    </div>
    <div class="row">
      <span class="muted">Target Node</span>
      <select id="w_target" style="flex:1">
        <option value="INC">INC</option><option value="MEA">MEA</option><option value="HO">HO</option>
        <option value="SFG1">SFG1</option><option value="SFG2">SFG2</option><option value="SFG3">SFG3</option><option value="SFG4">SFG4</option>
        <option value="SFG5">SFG5</option><option value="SFG6">SFG6</option><option value="SFG7">SFG7</option><option value="SFG8">SFG8</option>
        <option value="SFG9">SFG9</option><option value="SFG10">SFG10</option><option value="SFG11">SFG11</option><option value="SFG12">SFG12</option>
      </select>
    </div>
    <div class="row" style="gap:12px;flex-wrap:wrap">
      <label class="muted" style="display:flex;align-items:center;gap:8px"><input id="w_auto" type="checkbox"> Auto-steer</label>
      <button class="btn mini" id="w_pulse">Intent Pulse</button>
      <button class="btn mini" id="w_burst">Global Burst</button>
      <button class="btn" id="w_toggle">Pause</button>
      <button class="btn mini" id="w_reset">Reset</button>
    </div>
    <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-top:8px">
      <div class="panel" style="padding:8px;text-align:center"><div>Coupling</div><div class="v mono" id="m_coupling">0.00</div></div>
      <div class="panel" style="padding:8px;text-align:center"><div>Coherence</div><div class="v mono" id="m_coherence">0.00</div></div>
      <div class="panel" style="padding:8px;text-align:center"><div>Warp Readiness</div><div class="v mono" id="m_readiness">Idle</div></div>
    </div>
  `;

  // cache meter els for shadow loop updates
  window.__warpMeters = {
    coupling: document.getElementById('m_coupling'),
    coherence: document.getElementById('m_coherence'),
    readiness: document.getElementById('m_readiness')
  };

  // helpers
  function push(){
    window.__warpSet?.({
      bias: +bias.value,
      flux: +flux.value,
      bearing: +bearing.value,
      mag: +mag.value,
      gain: +gain.value,
      focus: focus.value,
      target: target.value,
      autoSteer: auto.checked
    });
  }

  // elements
  const bias=$('w_bias'), flux=$('w_flux'), bearing=$('w_bearing'), mag=$('w_mag'), gain=$('w_gain');
  const obias=$('wo_bias'), oflux=$('wo_flux'), obear=$('wo_bearing'), omag=$('wo_mag'), ogain=$('wo_gain');
  const focus=$('w_focus'), target=$('w_target'), auto=$('w_auto');
  const pulse=$('w_pulse'), burst=$('w_burst'), toggleBtn=$('w_toggle'), reset=$('w_reset');

  // bind
  ;[bias,flux,bearing,mag,gain].forEach(el=>{
    el.addEventListener('input', ()=>{
      if(el===bias) obias.textContent=(+bias.value).toFixed(2);
      if(el===flux) oflux.textContent=(+flux.value).toFixed(2);
      if(el===bearing) obear.textContent=bearing.value;
      if(el===mag) omag.textContent=(+mag.value).toFixed(2);
      if(el===gain) ogain.textContent=(+gain.value).toFixed(2);
      push();
    });
  });
  ;[focus,target,auto].forEach(el=> el.addEventListener('change', push));

  pulse.addEventListener('click', ()=> window.__warpBurstNode?.(target.value));
  burst.addEventListener('click', ()=>{
    ['INC','MEA','HO','SFG1','SFG2','SFG3','SFG4','SFG5','SFG6','SFG7','SFG8','SFG9','SFG10','SFG11','SFG12'].forEach(id=> window.__warpBurstNode?.(id));
  });
  toggleBtn.addEventListener('click', ()=>{
    const running = window.__warpToggle?.();
    toggleBtn.textContent = running ? 'Pause' : 'Resume';
  });
  reset.addEventListener('click', ()=>{
    window.__warpReset?.();
  });

  // initial push
  push();
})(); // end warp controls build

/* ===== Fix a tiny var typo introduced above ===== */
(function fixIntentStemBug(){
  // In mountWarpDock() we accidentally left `aconst = 0` which would throw in strict mode.
  // Nothing to do here because it was declared as a plain identifier; make sure no global leak:
  if(typeof aconst!=='undefined'){ try{ delete window.aconst; }catch(e){} }
})();

/* ===== Mnality: integrate first snippet into the right-side card ===== */
(function initMnality(){
  const elWrap = $('mn_symbol');
  const elCount = $('mn_strandCount');
  const rRange = $('mn_range');
  const nNumber = $('mn_number');
  const btnLight = $('mn_light');
  const copyright = $('mn_copyright');
  const yearFlash = $('mn_yearFlash');

  let strandCount = 3;

  function clampStrands(v){
    const val = Math.min(Math.max(2, parseInt(v||2,10)), 256);
    return val;
  }

  function flashYear(color="#6ef"){
    yearFlash.style.color = color;
    yearFlash.style.opacity = 1;
    yearFlash.style.transition = "opacity 0.5s ease-out, transform 0.5s ease-out";
    yearFlash.style.transform = "translateX(-50%) scale(1.08)";
    setTimeout(()=>{
      yearFlash.style.opacity = 0;
      yearFlash.style.transform = "translateX(-50%) scale(1)";
    }, 520);
  }

  function updateCopyrightYear(){
    const year = 2025 + strandCount;
    copyright.innerHTML = `&copy; Hrishi Mukherjee Horizons ${year}`;
    yearFlash.textContent = year;
  }

  function clearStrands(){
    [...elWrap.querySelectorAll('.mn_out')].forEach(e=>e.remove());
  }

  function renderStrands(){
    clearStrands();
    const originX = elWrap.clientWidth / 2;
    const originY = elWrap.clientHeight - 150; // matches input height
    for(let i=0;i<strandCount;i++){
      const strand = document.createElement('div');
      strand.className = 'mn_out';
      const angle = (Math.PI / 2) * (i / (strandCount - 1)) - Math.PI / 4;
      const dx = 100 * Math.sin(angle);
      const dy = 100 * Math.cos(angle);
      strand.style.top = `${originY}px`;
      strand.style.left = `${originX + dx}px`;
      strand.style.transform = `rotate(${angle * 180 / Math.PI}deg)`;
      strand.addEventListener('click', (e)=>{
        e.stopPropagation();
        strand.classList.toggle('mn_lit');
        // color flash picks from computed bg (approx)
        flashYear('#6ef');
        // Small bridge: nudge Intent magnitude based on lit ratio
        try{
          const lit = elWrap.querySelectorAll('.mn_out.mn_lit').length;
          const frac = Math.max(0.05, Math.min(1, lit/strandCount));
          intent.mag = frac; E.rngMag.value = frac; E.labMag.textContent = intent.mag.toFixed(2);
          buildART(); ensurePoints(); computeSkyAutoTarget();
          // also push to WarpDock bearing subtly from strand index
          const newBearing = (intent.bearing + (i*7)) % 360;
          intent.bearing = newBearing; E.rngBearing.value=newBearing; E.labBearing.textContent = `${Math.round(newBearing)}°`;
          window.__warpSet?.({ bearing:newBearing, mag:frac, gain:intent.gain });
        }catch(_){}
      });
      elWrap.appendChild(strand);
    }
  }

  function syncInputs(v){
    strandCount = clampStrands(v);
    rRange.value = strandCount;
    nNumber.value = strandCount;
    elCount.textContent = strandCount;
    updateCopyrightYear();
    renderStrands();
  }

  function lightRandomStrand(){
    const strands = elWrap.querySelectorAll('.mn_out');
    if(!strands.length) return;
    const idx = (Math.random()*strands.length)|0;
    const s = strands[idx];
    s.classList.add('mn_lit');
    flashYear('#6ef');
    // emit a Warp burst to tie UX together
    window.__warpBurstNode?.(['INC','MEA','HO','SFG1','SFG5','SFG9'][idx%6]);
  }

  // symbol click toggles a subtle glow (cosmetic)
  elWrap.addEventListener('click', ()=>{
    elWrap.classList.toggle('mn_lit');
  });

  rRange.addEventListener('input', e=> syncInputs(e.target.value));
  nNumber.addEventListener('input', e=> syncInputs(e.target.value));
  btnLight.addEventListener('click', lightRandomStrand);

  // initial
  syncInputs(3);
})(); // end Mnality init

</script>
</body>
</html>

